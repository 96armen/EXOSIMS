\documentclass[cleanfoot]{asme2ej}

\usepackage[]{graphicx}
\graphicspath{ {images/} }

\usepackage{enumitem}
\usepackage{amsmath,amssymb}
\usepackage{textcomp}
\usepackage[urlcolor=blue,linkcolor=red,colorlinks=true]{hyperref}
\usepackage[autostyle, english=american]{csquotes}
\MakeOuterQuote{"}

\title{Exoplanet Open-Source Imaging Mission Simulator (EXOSIMS) \\ Interface Control Document}

%%% first author
\author{Daniel Garrett and Dmitry Savransky
    \affiliation{
    Sibley School of Mechanical and Aerospace Engineering\\
	Cornell University\\
	Ithaca, NY 14853
    }	
}

\def\mf{\mathbf}
\def\mb{\mathbb}
\def\mc{\mathcal}
\newcommand{\R}{\mathbf{r}}
\newcommand{\bc}{\mathbf{b}}
\newcommand{\mfbar}[1]{\mf{\bar{#1}}}
\newcommand{\mfhat}[1]{\mf{\hat{#1}}}
\newcommand{\bmu}{\boldsymbol{\mu}}
\newcommand{\blam}{\boldsymbol{\Lambda}}
\newcommand{\refeq}[1]{Equation  (\ref{#1})} 
\newcommand{\reftable}[1]{Table \ref{#1}} 
\newcommand{\refch}[1]{Chapter  \ref{#1}} 
\newcommand{\reffig}[1]{Figure \ref{#1}}
\newcommand{\refcode}[1]{Listing \ref{#1}}
\newcommand{\intd}[1]{\ensuremath{\,\mathrm{d}#1}}
\newcommand{\leftexp}[2]{{\vphantom{#2}}^{#1}\!{#2}}
\newcommand{\leftsub}[2]{{\vphantom{#2}}_{#1}\!{#2}}
\newcommand{\fddt}[1]{\ensuremath{\leftexp{\mathcal{#1}}{\frac{\mathrm{d}}{\mathrm{d}t}}}}
\newcommand{\fdddt}[1]{\ensuremath{\leftexp{\mathcal{#1}}{\frac{\mathrm{d}^2}{\mathrm{d}t^2}}}}
\newcommand{\omegarot}[2]{\ensuremath{\leftexp{\mathcal{#1}}{\boldsymbol{\omega}}^{\mathcal{#2}}}}


\begin{document}

\maketitle    

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
{\it This document describes the extensible, modular, open source software framework EXOSIMS.  EXOSIMS creates end-to-end simulations of space-based exoplanet imaging missions using stand-alone software modules.  These modules are split into input and simulation module groups.  The input/output interfaces of each module and interactions of modules with each other are presented to give guidance on mission specific modifications to the EXOSIMS framework. Last Update: \today}
\end{abstract}

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{nomenclature}
\entry{EXOSIMS}{Exoplanet Open-Source Imaging Mission Simulator}
\entry{ICD}{Interface Control Document}
\entry{MJD}{Modified Julian Day}
\end{nomenclature}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INTRODUCTION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction} 
Building confidence in a mission concept's ability to achieve its science goals is always desirable.  Unfortunately, accurately modeling the science yield of an exoplanet imager can be almost as complicated as designing the mission.  It is challenging to compare science simulation results and systematically test the effects of changing one aspect of the instrument or mission design.

EXOSIMS (Exoplanet Open-Source Imaging Mission Simulator) addresses this problem by generating ensembles of mission simulations for exoplanet direct imaging missions to estimate science yields. It is designed to allow systematic exploration of exoplanet imaging mission science yields.  It consists of stand-alone modules written in Python which may be modified without requiring modifications to other portions of the code. This allows EXOSIMS to be easily used to investigate new designs for instruments, observatories, or overall mission designs independently. This document describes the required input/output interfaces for the stand-alone modules to enable this flexibility.

\subsection{Purpose and Scope} % Rework this section
This Interface Control Document (ICD) provides an overview of the software framework of EXOSIMS and some details on its component parts.  As the software is intended to be highly reconfigurable, operational aspects of the code are emphasized over implementational details.  Specific examples are taken from the coronagraphic instrument under development for WFIRST-AFTA.  The data inputs and outputs of each module are described. Following these guidelines will allow the code to be updated to accommodate new mission designs.

This ICD defines the input/output of each module and the interfaces between modules of the code.  This document is intended to guide mission planners and instrument designers in the development of specific modules for new mission designs.

%\subsection{Glossary}
%This section will contain definition of terms used throughout the document if needed.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% OVERVIEW 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Overview}
The terminology used to describe the software implementation is loosely based on the object-oriented Python framework upon which EXOSIMS is built.  The term module can refer to the object class prototype representing the abstracted functionality of one piece of the software, an implementation of this object class which inherits the attributes of the prototype, or an instance of this object class.  Input/output definitions of modules refer to the class prototype.  Implemented modules refer to the inherited class definition.  Passing modules (or their outputs) means the instantiation of the inherited object class being used in a given simulation.  Relying on strict inheritance for all implemented module classes provides an automated error and consistency-checking mechanism.  The outputs of a given object instance may be compared to the outputs of the prototype.  It is trivial to pre-check whether a given module implementation will work with the larger framework, and thus allows flexibility and adaptability.

\begin{figure}[ht]
    \begin{center}
        \begin{tabular}{c}
             \includegraphics[width=0.9\textwidth]{codeflow5}
        \end{tabular}
    \end{center}
    \caption{Flowchart of mission simulation. Each box represents a component software module which interacts with other modules as indicated by the arrows. The simulation modules pass all input modules along with their own output.  Thus, the Survey Ensemble module has access to all of the input modules and all of the upstream simulation modules.}
    \label{figure_framework}
\end{figure}

The overall framework of EXOSIMS is depicted in Fig.~\ref{figure_framework} where the component stand-alone software modules are classified as input modules and simulation modules.  The input modules include the Optical System, Star Catalog, Planet Population, Observatory, Planet Physical Model, Time Keeping, and Post-Processing modules.  These modules contain specific mission design parameters.  The simulation modules include Target List, Simulated Universe, Survey Simulation, and Survey Ensemble modules.  The simulation modules take information contained in the input modules and perform mission simulation tasks.  Any module may perform any number or kind of calculations using any or all of the input parameters provided.  They are only constrained by their input and output specification contained in this document.

\begin{figure}[ht]
    \begin{center}
        \begin{tabular}{c}
             \includegraphics[width=0.75\textwidth]{starcatalog_flowdown}
        \end{tabular}
    \end{center}
    \caption{Schematic of a sample implementation for the three module layers for the Star Catalog module. The Star Catalog prototype (top row) is immutable, specifies the input/output structure of the module along with all common functionality, and is inherited by all Star Catalog class implementations (middle row).  In this case, two different catalog classes are shown: one that reads in data from a SIMBAD catalog dump, and one which contains only information about a subset of known radial velocity targets.  The object used in the simulation (bottom row) is an instance of one of these classes, and can be used in exactly the same way in the rest of the code due to the common input/output scheme.}
    \label{fig:starcatalog_flowdown}
\end{figure}

\begin{figure}[ht]
    \begin{center}
        \begin{tabular}{c}
             \includegraphics[width=0.75\textwidth]{observatory_flowdown}
        \end{tabular}
    \end{center}
    \caption{Schematic of a sample implementation for the three module layers for the Observatory module. The Observatory prototype (top row) is immutable, specifies the input/output structure of the module along with all common functionality, and is inherited by all Observatory class implementations (middle row).  In this case, two different observatory classes are shown that differ only in the definition of the observatory orbit.  Therefore, the second implementation inherits the first (rather than directly inheriting the prototype) and overloads only the orbit method. The object used in the simulation (bottom row) is an instance of one of these classes, and can be used in exactly the same way in the rest of the code due to the common input/output scheme.}
    \label{fig:observatory_flowdown}
\end{figure}

Figures \ref{fig:starcatalog_flowdown} and \ref{fig:observatory_flowdown} show schematic representations of the three different apsects of a module, for the Star Catalog and Observatory modules, respectively.  Every module has a specific prototype that sets the input/output structure of the module and encodes any common functionality for all module class implementations.  The various implementations inherit the prototype and perform whatever processing is necessary, limited only by the preset input/output scheme.  Finally, in the course of running a simulation, an object is generated for each module class selected for that simulation.  The generated objects can be used in exactly the same way in the downstream code, regardless of what implementation they are instances of, due to the strict interface defined in the class prototypes.

For the input modules, the input specification is much more loosely defined than the output specification, as different implementations may draw data from a wide variety of sources.  For example, the star catalog may be implemented as reading values from a static file on disk, or may represent an active connection to a local or remote database.  The output specification for these modules, however, as well as both the input and output for the simulation modules, is entirely fixed so as to allow for generic use of all module objects in the simulation.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% GLOBAL SPECIFICATIONS (INCLUDE BETTER EXPLANATIONS)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Global Specifications}
Common references (units, frames of reference, etc.) are required to ensure interoperability between the modules of EXOSIM.  All of the references listed below must be followed.

\begin{description}
    \item[Common Epoch] \hfill \\ J2000
    \item[Common Reference Frame] \hfill \\ Heliocentric Equatorial (HE)
\end{description}

\subsection{Python Packages} 
EXOSIMS is an open source platform.  As such, packages and modules may be imported and used for calculations within any of the stand-alone modules.  The following commonly used Python packages are used for the WFIRST-specific implementation of EXOSIMS:

\texttt{
\begin{itemize}
    \item astropy
        \begin{itemize}
            \item astropy.constants
            \item astropy.coordinates
            \item astropy.time
            \item astropy.units
        \end{itemize}
    \item copy
    \item importlib
    \item numpy
        \begin{itemize}
            \item numpy.linalg 
        \end{itemize}
    \item os
        \begin{itemize}
            \item os.path 
        \end{itemize}
    \item pickle/cPickle
    \item scipy
        \begin{itemize}
            \item scipy.io
            \item scipy.special
            \item scipy.interpolate
        \end{itemize}
\end{itemize}
}

\subsection{Coding Conventions}
In order to allow for flexibility in using alternate or user-generated module implementations, the only requirement on any module is that it inherits (either directly or by inheriting another module implementation that inherits the prototype) the appropriate prototype.  

\subsubsection{Module Type}
It is always possible to check whether a module is an instance of a given prototype, for example:
\begin{verbatim}
isinstance(obj,EXOSIMS.Prototypes.Observatory.Observatory)
\end{verbatim}
However, it can be tedious to look up all of a given object's base classes so, for convenience, every prototype will provide a private variable \verb+_modtype+, which will always return the name of the prototype and should not be overwritten by any module code.  Thus, if the above example evaluates as \verb+True+, \verb+obj._modtype+ will return \verb+Observatory+.

\subsubsection{Callable Attributes}
Certain module attributes must be represented in a way that allows them to be parametrized by other values.  For example, the instrument throughput and contrast are functions of both the wavelength and the angular separation, and so must be encodable as such in the optical system module.  To accommodate this, as well as simpler descriptions where these parameters may be treated as static values, these and other attributes are defined as `callable'.  This means that they must be set as objects that can be called in the normal Python fashion, i.e., \verb+object(arg1,arg2,...)+.  

These objects can be function definitions defined in the code, or imported from other modules.  They can be \href{https://docs.python.org/2/reference/expressions.html#lambda}{lambda expressions} defined inline in the code.  Or they can be callable object instances, such as the various \href{http://docs.scipy.org/doc/scipy/reference/interpolate.html}{scipy interpolants}.  In cases where the description is just a single value, these attributes can be defined as dummy functions that always return the same value, for example:
\begin{verbatim}
def throughput(wavelength,angle):
     return 0.5
\end{verbatim}
or even more simply:
\begin{verbatim}
throughput = lambda wavelength,angle: 0.5
\end{verbatim}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BACKBONE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Backbone}
All simulation execution will be performed by the backbone.  This set of functions will have very limited built-in functionality, and will primarily be tasked with parsing the input specification described below, and then calling the specified instances of each of the framework modules, detailed in \S\ref{sec:modules}.  The backbone functionality will primarily be implemented in the Survey Simulation prototype \S\ref{sec:surveysim}, with any mission-specific execution variations introduced by method overloading in the inherited survey simulation implementation.

A simulation specification is a single JSON-formatted (\url{http://json.org/}) file that encodes user-settable parameters and module names.  The backbone will contain a reference specification with \emph{all} parameters and modules set.  In the initial parsing of the user-supplied specification, it will be merged with the reference specification such that any fields not set by the user will be assigned to their reference (default) values.   

The backbone will contain a specification parser that will check specification files for internal consistency.  For example, if modules carry mutual dependencies, the specification parser will return an error if these are not met for a given specification.  Similarly, if modules are selected with optional top level inputs, warnings will be generated if these are not set in the same specification files.

In addition to the specification parser, the backbone will contain a method for comparing two specification files and returning the difference between them.  Assuming that the files specify all user-settable values, this will be equivalent to simply performing a \verb+diff+ operation on any POSIX system.  The backbone diff function will add in the capability to automatically fill in unset values with their defaults.  For every simulation (or ensemble), an output specification will be written to disk along with the simulation results with all defaults used filled in.

The backbone will also contain an interactive function to help users generate specification files via a series of questions.

\subsection{Specification Format}
The JSON specification file will contain a series of objects with members enumerating various user-settable parameters, top-level members for universal settings (such as the mission lifetime) and arrays of objects for multiple related specifications, such as starlight suppression systems and science instruments.  The final array will contain module names (or paths on disk) for all modules.

\begin{verbatim}
{
  "universalParam1": value,
  "universalParam2": value,
  ...
  "NstarlightSuppressionSystems":2,
  "starlightSupressionSystems": [
    {
      "starlightSuppressionSystemNumber": 1,
      "type": "external",
      "detectionTimeMultiplier": value,
      "characterizationTimeMultiplier": value,
      "occulterDiameter": value,
      "NocculterDistances": 2,
      "occulterDistances: [
        {
         "occulterDistanceNumber": 1,
         "occulterDistance": value,
         "occulterBlueEdge": value,
         "occulterRedEdge": value,
         "IWA": value,
         "OWA": value,
         "PSFfile": "/data/mdo1_psf.fits",
         "throughputFile": "/data/mdo1_thru.fits",
         "contrastFile":  "/data1/mdo1_contrast.fits"
        },
        {
         "occulterDistanceNumber": 2,
         "occulterDistance": value,
         "occulterBlueEdge": value,
         "occulterRedEdge": value,
         "IWA": value,
         "OWA": value,
         "PSFfile": "/data/mdo1_psf.fits",
         "throughputFile": "/data/mdo1_thru.fits",
         "contrastFile":  "/data1/mdo1_contrast.fits"
        }
      ],
      "occulterWetMass": value,
      "occulterDryMass": value,
    },
    {
      "starlightSuppressionSystemNumber": 2,
      "type": "internal",
      "detectionTimeMultiplier": value,
      "characterizationTimeMultiplier": value,
      "IWA": value,
      "OWA": value,
      "PSFfile": "/data/coron1_psf.fits",
      "throughputFile": "/data/coron1_thru.fits",
      "contrastFile":  "/data1/coron1_contrast.fits"
    }
  ],
  "NscienceInstruments": 2
  "scienceInstruments": [
    {
      "scienceInstrumentNumber": 1,
      "type": "imager-EMCCD",
      "cic": value,
      "darkRate": value,
      "QE": value/filename
    },
    {
      "scienceInstrumentNumber": 2,
      "type": "IFS-CCD",
      "readNoise": value,
      "darkRate": value,
      "QE": value/filename,
      "readRate": value
    }
  ],
  modules: {
    "PlanetPopulation": "HZEarthTwins",
    "StarCatalog": "exocat3",
    "OpticalSystem": "hybridOpticalSystem1",
    "ZodiacalLight": "10xSolZodi",
    "BackgroundSources": "besanconModel",
    "PlanetPhysicalModel": "fortneyPlanets",
    "Observatory": "WFIRSTGeo",
    "TimeKeeping": "UTCtime",
    "PostProcessing": "KLIPpost",
    "Completeness": "BrownCompleteness",
    "TargetList": "WFIRSTtargets",
    "SimulatedUniverse": "simUniverse1",
    "SurveySimulation": "backbone1",
    "SurveyEnsemble": "localIpythonEnsemble"
  }
}
\end{verbatim}

\subsection{Modules Specification}
The final array in the input specification  (\verb+modules+) is a list of all the modules that define a particular simulation.  This is the only part of the specification that will not be filled in by default if a value is missing - each module must be explicitly specified. The order of the modules in the list is arbitrary, so long as they are all present. 

If the module implementations are in the appropriate subfolder in the EXOSIMS tree, then they can be specified by the module name.  However, if you wish to use an implemented module outside of the EXOSISM directory, then you need to specify it via its full path in the input specification.

\emph{All modules, regardless of where they are stored on disk must inherit the appropriate prototype.}

\subsection{Universal Parameters}
These parameters apply to all simulations, and are described in detail in their specific module definitions:

\begin{itemize}[leftmargin=1in,font={\ttfamily}]
\item[missionLifetime]  The total mission lifetime in years.  When the mission time is equal or greater to this value, the mission simulation stops.
\item[missionPortion]  The portion of the mission dedicated to exoplanet science, given as a value between 0 and 1.  When the total integration time plus observation overhead time is equal to the missionLifetime $\times$ missionPortion the mission simulation stops.
\item[lambda]  Central or detection wavelength.
\item[deltaLambda]  Detection bandwidth.
\item[shapeFac]  Telescope aperture shape factor.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INPUT MODULES DESCRIPTION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Input Modules}\label{sec:modules}
The input modules include Planet Population, Star Catalog, Optical System, Zodiacal Light, Background Sources, Planet Physical Model, Observatory, Time Keeping, and Post-Processing.  These modules encode and/or generate all of the information necessary to perform mission simulations.  The specific mission design determines the functionality of each input module, while inputs and outputs of these modules remain the same (in terms of data type and variable representations).  This section defines the functionality, major tasks, input, output, and interface of each of these modules.

% PLANET POPULATION

\subsection{Planet Population}
The Planet Population module encodes the density functions of all required planetary parameters, both physical and orbital. These include semi-major axis, eccentricity, orbital orientation, radius, mass, and geometric albedo (see ~\ref{sec:pdfs}). Certain parameter models may be empirically derived while others may come from analyses of observational surveys.  This module also encodes the limits on all parameters to be used for sampling the distributions and determining derived cutoff values such as the maximum target distance for a given instrument's IWA.

\begin{figure}[ht]
    \begin{center}
        \begin{tabular}{c}
             \includegraphics[width=0.6\textwidth]{orbit_diagram}
        \end{tabular}
    \end{center}
    \caption{\label{fig:orbit_diagram} Definition of reference frames and coordinates of simulated exosystems.  The observer lies along the negative $\mf s_3$ axis so that the observer-star unit vector is $+\mf s_3$.}
\end{figure}

The coordinate system of the simulated exosystems is defined as in \reffig{fig:orbit_diagram}.  The observer looks at the target star along the $\mathbf{s}_3$ axis, located at a distance $-d\mathbf{s}$ from the target at the time of observation. The argument of periapse, inclination,  and longitude of the ascending node ($\omega, I, \Omega$) are defined as a 3-1-3 rotation about the unit vectors defining the $\mathcal{S}$ reference frame.  This rotation defines the standard Equinoctial reference frame ($\mfhat{e}, \mfhat{q}, \mfhat{h}$), with the true anomaly ($\nu$) measured from $\mfhat{e}$).  The planet-star orbital radius vector $\mf r_{P/S}$ is projected into the $\mf s_1, \mf s_2$ plane as the projected separation vector $\mf s$, with magnitude $s$, and the phase (star-planet-observer) angle ($\beta$) is closely approximated by the angle between $\mf r_{P/s}$ and its projection onto $\mf s_3$.

The Planet Population module does not model the physics of planetary orbits or the amount of light reflected or emitted by a given planet, but rather encodes the statistics of planetary occurrence and properties. 

\label{sec:planetpopulation}
\subsubsection{Planet Population Object Attribute Initialization Input/Output Description} 
\subsubsection*{Inputs}
\begin{itemize}
    \item
    \begin{description}
        \item[User specification] \hfill \\
        Information from simulation specification JSON file organized into a Python dictionary. If the below key: value pairs are missing from the dictionary, the Planet Population object attributes will be assigned the default values listed.
        \begin{description}
            \item specs["a\_min"] \hfill \\
            Minimum semi-major axis in $ AU $. Default value is 0.01.
            \item specs["a\_max"] \hfill \\
            Maximum semi-major axis in $ AU $. Default value is 10.0.
            \item specs["e\_min"] \hfill \\
            Minimum eccentricity. Default value is 0.001.
            \item specs["e\_max"] \hfill \\
            Maximum eccentricity. Default value is 0.8.
            \item specs["w\_min"] \hfill \\
            Minimum argument of perigee in degrees. Default value is 0.
            \item specs["w\_max"] \hfill \\
            Maximum argument of perigee in degrees. Default value is 360.
            \item specs["O\_min"] \hfill \\
            Minimum right ascension of the ascending node. Default value is 0.
            \item specs["O\_max"] \hfill \\
            Maximum right ascension of the ascending node. Default value is 360.
            \item specs["p\_min"] \hfill \\
            Minimum planetary geometric albedo. Default value is 0.0004.
            \item specs["p\_max"] \hfill \\
            Maximum planetary geometric albedo. Default value is 0.6.
            \item specs["I\_min"] \hfill \\
            Minimum inclination in degrees. Default value is 0.
            \item specs["I\_max"] \hfill \\
            Maximum inclination in degrees. Default value is 180.
            \item specs["R\_min"] \hfill \\
            Minimum planetary radius in $ km $. Default value is 1930.
            \item specs["R\_max"] \hfill \\
            Maximum planetary radius in $ km $. Default value is 145844.
            \item specs["Mp\_min"] \hfill \\
            Minimum planetary mass in $ kg $. Default value is 1.196e+23.
            \item specs["Mp\_max"] \hfill \\
            Maximum planetary mass in $ kg $. Default value is 5.411e+28.
            \item specs["scaleOrbits"] \hfill \\
            Boolean where True means planetary orbits are scaled by the square root of stellar luminosity. Default value is False.
        \end{description}
    \end{description}
\end{itemize}

\subsubsection*{Outputs}
\begin{itemize}
    \item
    \begin{description}
        \item[PlanetPopulation.arange] \hfill \\
        Semi-major axis range defined as numpy.array([a\_min, a\_max]) (astropy Quantity object initially set in $ AU $)
        \item[PlanetPopulation.erange] \hfill \\
        Eccentricity range defined as numpy.array([e\_min, e\_max])
        \item[PlanetPopulation.wrange] \hfill \\
        Argument of perigee range defined as numpy.array([w\_min, w\_max])
        \item[PlanetPopulation.Orange] \hfill \\
        Right ascension of the ascending node range defined as numpy.array([O\_min, O\_max])
        \item[PlanetPopulation.prange] \hfill \\
        Planetary geometric albedo range defined as numpy.array([p\_min, p\_max])
        \item[PlanetPopulation.Irange] \hfill \\
        Planetary orbital inclination range defined as numpy.array([I\_min, I\_max])
        \item[PlanetPopulation.Rrange] \hfill \\
        Planetary radius range defined as numpy.array([R\_min, R\_max]) (astropy Quantity object or astropy constant objects, e.g., astropy.constant.R\_earth initially set in $ km $)
        \item[PlanetPopulation.Mprange] \hfill \\
        Planetary mass range defined as numpy.array([Mp\_min, Mp\_max]) (astropy Quantity object initially set in $ kg $)
        \item[PlanetPopulation.scaleOrbits] \hfill \\
        Boolean where True means planetary orbits are scaled by the square root of stellar luminosity
        \item[PlanetPopulation.rrange] \hfill \\
        Planetary orbital radius range defined as numpy.array([r\_min, r\_max]) derived from PlanetPopulation.arange and PlanetPopulation.erange (astropy Quantity object initially set in $ km $)
        
    \end{description}
\end{itemize}

\subsubsection{Planet Population Probability Density Functions} \label{sec:pdfs}
Each of the probability density functions contained in the Planet Population module are implemented as functions.  The input to these functions is the quantity of interest and the output is value of the probability density function.  These functions are provided so that the Simulated Universe module may sample these quantities from the probability density functions and create a simulated universe of synthetic planets.  The required functions are given as follows:

\begin{itemize}
    \item 
    \begin{description}
        \item[semi\_axis] \hfill \\
        Probability density function for semi-major axis
        \item[eccentricity] \hfill \\
        Probability density function for eccentricity
        \item[arg\_perigee] \hfill \\
        Probability density function for argument of perigee
        \item[RAAN] \hfill \\
        Probability density function for right ascension of the ascending node
        \item[radius] \hfill \\
        Probability density function for planetary radius
        \item[mass] \hfill \\
        Probability density function for planetary mass
        \item[albedo] \hfill \\
        Probability density function for planetary geometric albedo
        \item[inclination] \hfill \\
        Probability density function for orbital inclination
    \end{description}
\end{itemize}

% STAR CATALOG

\subsection{Star Catalog} \label{sec:starcatalog}
The Star Catalog module includes detailed information about potential target stars drawn from general databases such as SIMBAD, mission catalogs such as Hipparcos, or from existing curated lists specifically designed for exoplanet imaging missions.  Information to be stored, or accessed by this module will include target positions and proper motions at the reference epoch, catalog identifiers (for later cross-referencing), bolometric luminosities, stellar masses, and magnitudes in standard observing bands.  Where direct measurements of any value are not available, values are synthesized from ancillary data and empirical relationships, such as color relationships and mass-luminosity relations.

This module does not provide any functionality for picking the specific targets to be observed in any one simulation, nor even for culling targets from the input lists where no observations of a planet could take place.  This is done in the Target List module as it requires interactions with the Planet Population (to determine the population of interest), Optical System (to define the capabilities of the instrument), and Observatory (to determine if the view of the target is unobstructed) modules.

\subsubsection{Star Catalog Object Attribute Initialization Input/Output Description} 
The Star Catalog prototype creates empty 1D NumPy ndarrays for each of the output quantities listed below.  Specific Star Catalog modules populate the values as appropriate.

\subsubsection*{Inputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[star catalog information] \hfill \\
        Information from an external star catalog 
    \end{description}
\end{itemize}

\subsubsection*{Outputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[StarCatalog.Name] \hfill \\
        1D NumPy ndarray of star names
        \item[StarCatalog.Type] \hfill \\
        1D NumPy ndarray of star types
        \item[StarCatalog.Spec] \hfill \\
        1D NumPy ndarray of spectral types
        \item[StarCatalog.parx] \hfill \\
        1D NumPy ndarray of parallax in milliarcseconds
        \item[StarCatalog.Umag] \hfill \\
        1D NumPy ndarray of U magnitude
        \item[StarCatalog.Bmag] \hfill \\
        1D NumPy ndarray of B magnitude
        \item[StarCatalog.Vmag] \hfill \\
        1D NumPy ndarray of V magnitude
        \item[StarCatalog.Rmag] \hfill \\
        1D NumPy ndarray of R magnitude
        \item[StarCatalog.Imag] \hfill \\
        1D NumPy ndarray of I magnitude
        \item[StarCatalog.Jmag] \hfill \\
        1D NumPy ndarray of J magnitude
        \item[StarCatalog.Hmag] \hfill \\
        1D NumPy ndarray of H magnitude
        \item[StarCatalog.Kmag] \hfill \\
        1D NumPy ndarray of K magnitude
        \item[StarCatalog.dist] \hfill \\
        1D NumPy ndarray of distance in parsecs
        \item[StarCatalog.BV] \hfill \\
        1D NumPy ndarray of B-V Johnson magnitude
        \item[StarCatalog.MV] \hfill \\
        1D NumPy ndarray of absolute V magnitude
        \item[StarCatalog.BC] \hfill \\
        1D NumPy ndarray of bolometric correction
        \item[StarCatalog.L] \hfill \\
        1D NumPy ndarray of stellar luminosity in Solar luminosities
        \item[StarCatalog.coords] \hfill \\
        Astropy \href{http://astropy.readthedocs.org/en/latest/api/astropy.coordinates.SkyCoord.html}{SkyCoord object} containing list of star positions (e.g., right ascension and declination)
        \item[StarCatalog.pmra] \hfill \\
        1D NumPy ndarray of proper motion in right ascension in milliarcseconds/year
        \item[StarCatalog.pmdec] \hfill \\
        1D NumPy ndarray of proper motion in declination in milliarcseconds/year
        \item[StarCatalog.rv] \hfill \\
        1D NumPy ndarray of radial velocity in kilometers/second
        \item[StarCatalog.Binary\_Cut] \hfill \\
        Boolean 1D NumPy ndarray where True is companion star closer than 10 arcseconds
    \end{description}
\end{itemize}

% OPTICAL SYSTEM NEEDS UPDATING

\subsection{Optical System}
The Optical System module contains all of the necessary information to describe the effects of the telescope and starlight suppression system on the target star and planet wavefronts.  This requires encoding the design of both the telescope optics and the specific starlight suppression system, whether it be an internal coronagraph or an external occulter.  The encoding can be achieved by specifying Point Spread Functions (PSF) for on- and off-axis sources, along with angular separation and wavelength dependent contrast and throughput definitions.  At the opposite level of complexity, the encoded portions of this module may be a description of all of the optical elements between the telescope aperture and the imaging detector, along with a method of propagating an input wavefront to the final image plane.  Intermediate implementations can include partial propagations, or collections of static PSFs representing the contributions of various system elements.  The encoding of the optical train will allow for the extraction of specific bulk parameters including the instrument inner working angle (IWA), outer working angle (OWA), and mean and max contrast and throughput.

Finally, the Optical System must also include a description of the science instrument.  The baseline instrument is assumed to be an imaging spectrometer.  The encoding must provide the spatial and wavelength coverage of the instrument as well as sampling for each, along with detector details such as read noise, dark current, and readout cycle.

The Optical System module has two tasks used in simulation.  \verb+calc_maxintTime+ is called from the Target List module to calculate the maximum integration time for each star in the target list (see ~\ref{sec:calcmaxintTimetask}).  \verb+calc_intTime+ is called from the Survey Simulation module to calculate integration times for a target system (see ~\ref{sec:calcintTimetask}).  The inputs and outputs for the Optical System tasks are depicted in Fig. \ref{fig:opticalsysmodule}.

\begin{figure}[ht]
    \begin{center}
        \begin{tabular}{c}
             \includegraphics[width=\textwidth]{OpticalSysTasks}
        \end{tabular}
    \end{center}
    \caption{\label{fig:opticalsysmodule} Depiction of Optical System module tasks including inputs and outputs (see ~\ref{sec:calcmaxintTimetask} and ~\ref{sec:calcintTimetask}).}
\end{figure}


\label{sec:opticalsystem}
\subsubsection{Optical System Object Attribute Initialization Input/Output Description} 

The specific set of inputs to this module will vary based on the simulation approach used.  Here we define the specification for the case where static PSF(s), derived from external diffraction modeling, are used to describe the system.  Note that some of the inputs are coronagraph or occulter specific, and will be expected based on the "internal" or "external" starlight suppression system keyword, respectively.


\subsubsection*{Inputs}
\begin{itemize}
    \item
    \begin{description}
        \item[User specification] \hfill \\
        Information from simulation specification JSON file organized into a Python dictionary.  For multiple systems, there will be an array of dictionaries. If the below key: value pairs are missing from the input specification, the Optical System object attributes will be assigned the default values listed. 
        \begin{description}
            \item specs["lambda"] \hfill \\
            Central detection wavelength in $ nm $. Default value is 500.
            \item specs["deltaLambda"] \hfill \\
            Detection bandwidth $ \Delta\lambda $ in $ nm $. Default value is 100.
            \item specs["shapeFac"] \hfill \\
            Shape factor (also known as fill factor) so that $ shapeFac \times diameter^2 = Area $. Default value is $ \frac{\pi}{4} $.
            \item specs["pupilArea"] \hfill \\
            Entrance pupil area in $ m^2 $. Default value is $ 4\pi $.
            \item specs["SNchar"] \hfill \\
            Signal to Noise Ratio for characterization. Default value is 11.
            \item specs["pixelArea"] \hfill \\
            Pixel area in $ m^2 $. Default value is 1e-10.
            \item specs["focalLength"] \hfill \\
            Focal length in $ m $. Default value is 240.
            \item specs["IWA"] \hfill \\
            Inner Working Angle in $ arcseconds $. Default value is 0.075.
            \item specs["OWA"] \hfill \\
            Outer Working Angle in $ arcseconds $. Set to Inf for no OWA. Default value is Inf.
            \item specs["throughput"] \hfill \\
            Coronagraph throughput: either a scalar for constant throughput, a two-column array for angular separation-dependent throughput, where the first column contains the separations in arcseconds, or a 2D array for angular separation- and wavelength- dependent throughput, where the first column contains the angular separation values in as and the first row contains the wavelengths in nm.  The ranges on all parameters must be consistent with the values for the IWA, OWA, lambda and deltaLambda inputs.  May be data or FITS filename. Default is scalar 0.5.
            \item specs["dMagLim"] \hfill \\
            Limiting $ \Delta$mag (difference in magnitude between star and planet). Default value is minimum of contrast.
            \item specs["contrast"] \hfill \\
            Optical system contrast: either a scalar for constant contrast, a two-column array for angular separation-dependent contrast, where the first column contains the separations in arcseconds, or a 2D array for angular separation- and wavelength- dependent contrast, where the first column contains the angular separation values in as and the first row contains the wavelengths in nm.  The ranges on all parameters must be consistent with the values for the IWA, OWA, lambda and deltaLambda inputs. May be data or FITS filename. Default is scalar 1e-10.
            \item specs["dr"] \hfill \\
            Detector dark current rate per pixel in units of electrons/second. Default value is 0.001.
            \item specs["sigma\_r"] \hfill \\
            Detector read noise in electrons/read. Default value is 3.
            \item specs["t\_exp"] \hfill \\
            Exposure time per read in $ s $. Default value is 1000.
            \item specs["QE"] \hfill \\
            Detector quantum efficiency: either a scalar for constant QE, or a two-column array for wavelength-dependent QE, where the first column contains the wavelengths in nm. The ranges on all parameters must be consistent with the values for lambda and deltaLambda inputs. May be data or FITS filename. Default is scalar 0.5.
            \item specs["attenuation"] \hfill \\
            Non-coronagraph attenuation, equal to the throughput of the optical system without the coronagraph elements. Default value is 0.57.
            \item specs["PSF"] \hfill \\
            Instrument point spread function. Either a 2D array of a single-PSF, or a 3D array of wavelength-dependent PSFs. May be data or FITS filename. Default is numpy.ones((3,3)).
            \item specs["PSFsampling"] \hfill \\
            Sampling of the PSF in arcsec/pixel. Default value is 10.
            \item specs["specLambda"] \hfill \\
            Spectral wavelength of interest in nm. Default value is equal to lambda.
            \item specs["Rspec"] \hfill \\
            (Specific to spectrometers) Spectral resolving power defined as $\lambda/\Delta\lambda$. Default value is 70.
            \item specs["optical\_oh"] \hfill \\
            Optical system overhead time in $days$.  Default value is 1 day.  This is the (assumed constant) amount of time required to set up the optical system (i.e., dig the dark hole or do fine alignment with the occulter).  It is added to every observation, and is separate from the observatory overhead defined in the observatory module, which represents the observatory's settling time.  Both overheads are added to the integration time to determine the full duration of each detection observation.
            \item specs["intCutoff"] \hfill \\
            Maximum allowed integration time in $ days $. Default value is 50. No integrations will be started that would take longer than this value.
            \item specs["detectionTimeMultiplier"]\hfill \\
            Duty cycle of a detection observation.  If only a single integration is required for the initial detection observation, then this value is 1.  Otherwise, it is equal to the number of discrete integrations needed to cover the full field of view (i.e., if a shaped pupil with a dark hole that covers 1/3 of the field of view is used for detection, this value would equal 3).
            \item specs["characterizationTimeMultiplier"]\hfill \\
            Characterization duty cycle.  If only a single integration is required for the initial detection observation, then this value is 1.  Otherwise, it is equal to the number of discrete integrations needed to cover the full wavelength band and all required polarization states.  For example, if the band is split into three sub-bands, and there are two polarization states that must be measured, and each of these must be done sequentially, then this value would equal 6.  However, if the three sub-bands could be observerd at the same time (e.g., by separate detectors) then the value would by two (for the two polarization states).
            \item specs["occulterDiameter"]\hfill \\
            Occulter diameter in $ m $.  Measured petal tip-to-tip.
            \item specs["NocculterDistances"]\hfill \\
            Number of telescope separations the occulter operates over (number of occulter bands). If greater than 1, then the occulter description is an array of dicts.
            \item specs["occulterDistance"]\hfill \\
            Telescope-occulter separation in $km$.
            \item specs["occulterBlueEdge"]\hfill \\
            Occulter blue end of wavelength band in $nm$.
            \item specs["occulterRedEdge"]\hfill \\
            Occulter red end of wavelength band in $nm$.
        \end{description}
    \end{description}
\end{itemize}

For all values that may be either scalars or interpolants, in the case where scalar values are given, the optical system module will automatically wrap them in lambda functions so that they become callable (just like the interpolant) but will always return the same value for all arguments.  The inputs for interpolants may be filenames with tabulated data, or NumPy ndarrays of argument and data (in that order in rows so that input[0] is the argument and input[1] is the data).

\subsubsection*{Outputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[OpticalSystem.lambda] \hfill \\
        Detection wavelength (astropy Quantity object initially set in $ nm $)
        \item[OpticalSystem.deltaLambda] \hfill \\
        Detection bandwidth $ \Delta\lambda $ (astropy Quantity object initially set in $ nm $)
        \item[OpticalSystem.shapeFac] \hfill \\
        Shape factor so that $ shapeFac \times diameter^2 = Area $
        \item[OpticalSystem.pupilArea] \hfill \\
        Entrance pupil area (astropy Quantity object initially set in $ m^{2} $)
        \item[OpticalSystem.SNchar] \hfill \\
        Signal to Noise Ratio for characterization
        \item[OpticalSystem.pixelArea] \hfill \\
        Pixel area (astropy Quantity object initially set in $ m^{2} $
        \item[OpticalSystem.focalLength] \hfill \\
        Focal length (astropy Quantity object initially set in $ m $)
        \item[OpticalSystem.IWA] \hfill \\
        Inner Working Angle (astropy Quantity object initially set in $ arcseconds $)
        \item[OpticalSystem.OWA] \hfill \\
        Outer Working Angle (astropy Quantity object initially set in $ as $)
        \item[OpticalSystem.dMagLim] \hfill \\
        Limiting $ \Delta$mag (difference in magnitude between star and planet)
        \item[OpticalSystem.throughput] \hfill \\
        Optical system throughput. Callable object with arguments of wavelength, valid between the lowest and highest wavelengths to be observed, and angular separation, valid between the IWA and OWA.  For a fixed throughput, the callable object may always return a single value.  
        \item[OpticalSystem.contrast] \hfill \\
        Optical system contrast.  Callable object with arguments of wavelength, valid between the lowest and highest wavelengths to be observed, and angular separation, valid between the IWA and OWA.  For a fixed contrast, may always return a single value. 
        \item[OpticalSystem.dr] \hfill \\
        Detector dark-current rate per pixel (astropy Quantity object initially set in $ \frac{1}{s} $)
        \item[OpticalSystem.sigma\_r] \hfill \\
        Detector read noise in electrons/read
        \item[OpticalSystem.t\_exp] \hfill \\
        Exposure time per read (astropy Quantity object initially set in $ s $)
        \item[OpticalSystem.QE] \hfill \\
        Detector quantum efficiency.  Callable object with argument of wavelength, valid between the lowest and highest wavelengths to be observed (as defined by lambda and deltaLambda), inclusive, and must assume an argument in nanometers.
        \item[OpticalSystem.attenuation] \hfill \\
        Non-coronagraph attenuation, equal to the throughput of the optical system without the coronagraph elements.
        \item[OpticalSystem.PSF] \hfill \\
        Instrument point spread function.  Callable object with arguments of wavelength, valid between the lowest and highest wavelengths to be observed, and angular separation, valid between the IWA and OWA.  Returns a 2D NumPy ndarray.  The core of the PSF is normalized to 1, so that all throughput terms are combined in the througput variable above. 
        \item[OpticalSystem.PSFSampling] \hfill \\
        Sampling of PSF in arcsec/pixel (astropy Quantity object initially set in arcseconds)
        \item[OpticalSystem.telescopeKeepout] \hfill \\
        Telescope keepout angle in degrees
        \item[OpticalSystem.specLambda] \hfill \\
        Spectral wavelength of interest (astropy Quantity object initially set in $ nm $)
        \item[OpticalSystem.Rspec] \hfill \\
        Spectral resolving power
        \item[OpticalSystem.intCutoff] \hfill \\
        Maximum allowed integration time (astropy Quantity object initially set in $ days $)
        \item[OpticalSystem.detectionTimeMultiplier]\hfill \\
        Duty cycle of a detection observation. 
        \item[OpticalSystem.characterizationTimeMultiplier]\hfill \\
        Characterization duty cycle.
        \item[OpticalSystem.occulterDiameter]\hfill \\
        Occulter diameter.   (astropy Quantity object initially set in $ m $)
        \item[OpticalSystem.occulterDistance]\hfill \\
        Telescope-occulter separation. (astropy Quantity object initially set in $ km $)
        \item[OpticalSystem.occulterBlueEdge]\hfill \\
        Occulter blue end of wavelength band. (astropy Quantity object initially set in $ nm $)
        \item[OpticalSystem.occulterRedEdge]\hfill \\
        Occulter red end of wavelength band. (astropy Quantity object initially set in $ nm $)
    \end{description}
\end{itemize}

\subsubsection{calc\_maxintTime Task Input/Output Description} \label{sec:calcmaxintTimetask}
The \verb+calc_maxintTime+ task calculates the maximum integration time for each star in the target list.  This task is called from the Target List module.
\subsubsection*{Inputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[targlist] \hfill \\
        Instantiated Target List object from Target List module see ~\ref{sec:targetlist} for definition of available attributes
    \end{description}
\end{itemize}

\subsubsection*{Output}
\begin{itemize}
    \item
    \begin{description}
        \item[maxintTime] \hfill \\
        Maximum integration time for each target star as 1D NumPy ndarray with astropy Quantity units of time attached
    \end{description}
\end{itemize}

\subsubsection{calc\_intTime Task Input/Output Description} \label{sec:calcintTimetask}
The \verb+calc_intTime+ task calculates the integration time required for a specific target system.  This task is called from the Survey Simulation module.
\subsubsection*{Inputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[targlist] \hfill \\
        Instantiated Target List object from Target List module see ~\ref{sec:targetlist} for definition of available attributes
        \item[universe] \hfill \\
        Instantiated Simulated Universe object from Simulated Universe module see ~\ref{sec:simulateduniverse} for definition of available attributes
        \item[s\_ind] \hfill \\
        Index of target star from Target List module
        \item[planInds] \hfill \\
        Index of planets belonging to target star
    \end{description}
\end{itemize}

\subsubsection*{Output}
\begin{itemize}
    \item 
    \begin{description}
        \item[intTime] \hfill \\
        Integration time for each of the planets indexed by planInds as 1D NumPy ndarray with astropy Quantity units of time attached 
    \end{description}
\end{itemize}

% ZODIACAL LIGHT 

\subsection{Zodiacal Light}\label{sec:zodiacallight}

The Zodiacal Light module contains the \verb+fzodi+ task.  This task calculates the contribution of both local and exozodiacal light levels for each planet.  The inputs and outputs for the Zodiacal Light task are depicted in Fig. ~\ref{fig:zodiacallightmodule}.

\begin{figure}[ht]
    \begin{center}
        \begin{tabular}{c}
             \includegraphics[width=0.8\textwidth]{ZodiTasks}
        \end{tabular}
    \end{center}
    \caption{\label{fig:zodiacallightmodule} Depiction of Zodiacal Light module task including inputs and outputs (see ~\ref{sec:fzoditask}).}
\end{figure}

\subsubsection{Zodiacal Light Object Attribute Initialization Input/Output Description}
\subsubsection*{Input}
\begin{itemize}
    \item
    \begin{description}
        \item[User specification] \hfill \\
        Information from simulation specification JSON file organized into a Python dictionary. If the below key: value pairs are missing from the dictionary, the Zodiacal Light object attributes will be assigned the default values listed.
        \begin{description}
            \item specs["exozodi"] \hfill \\
            Exo-zodi level in zodi
            \item specs["exozodiVar"] \hfill \\
            Exo-zodi variation (variance of log-normal distribution)
        \end{description}
    \end{description}
\end{itemize}

\subsubsection*{Output}
\begin{itemize}
    \item 
    \begin{description}
        \item[ZodiacalLight.exozodi] \hfill \\
        Exo-zodi level in zodi
        \item[ZodiacalLight.exozodiVar] \hfill \\
        Exo-zodi variation (variance of log-normal distribution)
    \end{description}
\end{itemize}

\subsubsection{fzodi Task Input/Output Description} \label{sec:fzoditask}
The \verb+fzodi+ task returns exozodi levels for planetary systems.  This functionality is used by the Simulated Universe module.

\subsubsection*{Inputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[Inds] \hfill \\
        1D NumPy ndarray of indices mapping planets to stars contained in the target list
        \item[I] \hfill \\
        1D NumPy ndarray of planet inclination in degrees
        \item[targlist] \hfill \\
        Instantiated Target List object from Target List module see ~\ref{sec:targetlist} for description of functionality and attributes
    \end{description}
\end{itemize}

\subsubsection*{Outputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[fzodicurr] \hfill \\
        1D NumPy ndarray containing exozodiacal light levels in zodi
    \end{description}
\end{itemize}

\subsection{Background Sources}\label{sec:backgroundsources}

The Background Sources module will provide density of background sources for a given target based on its coordinates and the integration depth.  This will be used in the post-processing module to determine false alarms based on confusion.  The prototype module has no inputs and only a single function: \verb+dNbackground+.

\subsubsection{dNbackground}
\subsubsection*{Inputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[coords] \hfill \\
        Astropy \href{http://astropy.readthedocs.org/en/latest/api/astropy.coordinates.SkyCoord.html}{SkyCoord object} containing list of star positions (e.g., right ascension and declination), typically passed from target list.
        \item[intDepths] \hfill \\
        Array-like (list or ndarray) of floating point values equal to absolute magnitude (in the detection band) of dark hole to be produced for each target. Dimension must match the length of the coords input.
    \end{description}
\end{itemize}

\subsubsection*{Outputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[dN] \hfill \\
        Numpy ndarray matching size of inputs, containing number densities of background sources for given targets in number per square arcminute.
    \end{description}
\end{itemize}


% PLANET PHYSICAL MODEL NEEDS UPDATING

\subsection{Planet Physical Model NEEDS UPDATING} \label{sec:planetphysicalmodel}
The Planet Physical Model module contains models of the light emitted or reflected by planets in the wavelength bands under investigation by the current mission simulation.  It takes as inputs the physical quantities sampled from the distributions in the Planet Population module and generates synthetic spectra (or band photometry, as appropriate).  The specific implementation of this module can vary greatly, and can be based on any of the many available planetary geometric albedo, spectra and phase curve models.

Planet Physical Model TASKS:

% OBSERVATORY

\subsection{Observatory}
The Observatory module contains all of the information specific to the space-based observatory not included in the Optical System module. The module has two main tasks: \verb+orbit+ and \verb+keepout+, which are implemented as functions within the module. 

The observatory orbit plays a key role in determining which of the target stars may be observed for planet finding at a specific time during the mission lifetime. The Observatory module's \verb+orbit+ task takes the current mission time as input and outputs the observatory's position vector. The position vector is standardized throughout the modules to be referenced to a heliocentric equatorial frame at the J2000 epoch. The observatory's position vector is used in the \verb+keepout+ task and Target List module to determine which of the stars are observable at the current mission time.

The \verb+keepout+ task determines which target stars are observable at a specific time during the mission simulation and which are unobservable due to bright objects within the field of view such as the sun, moon, and solar system planets.  The keepout volume is determined by the specific design of the observatory and, in certain cases, by the starlight suppression system.  The \verb+keepout+ task takes the current mission time and Star Catalog or Target List module output as inputs and outputs a list of the target stars which are observable at the current time. It constructs position vectors of the target stars and bright objects which may interfere with observations with respect to the observatory. These position vectors are used to determine if bright objects are in the field of view for each of the potential stars under exoplanet finding observation.  If there are no bright objects obstructing the view of the target star, it becomes a candidate for observation in the Survey Simulation module.  The solar keepout is typically encoded as allowable angle ranges for the spacecraft-star unit vector as measured from the spacecraft-sun vector.

In addition to these tasks, the observatory definition can also encode finite resources used by the observatory throughout the mission.  The most important of these is the fuel used for stationkeeping and repointing, especially in the case of occulters which must move significant distances between observations.  Other considerations could include the use of other volatiles such as cryogens for cooled instruments, which tend to deplete solely as a function of mission time.  This module also allows for detailed investigations of the effects of orbital design on the science yield, e.g., comparing the baseline geosynchronous 28.5\textdegree{} inclined orbit for WFIRST-AFTA with an L2 halo orbit proposed for other exoplanet imaging mission concepts. 

The inputs, outputs, and updated attributes of the required Observatory module tasks are depicted in Fig. ~\ref{fig:observatorymodule}.

\begin{figure}[ht]
    \begin{center}
        \begin{tabular}{c}
             \includegraphics[width=0.9\textwidth]{observatory3}
        \end{tabular}
    \end{center}
    \caption{\label{fig:observatorymodule} Depiction of Observatory module tasks including inputs, outputs, and updated attributes (see ~\ref{sec:orbittask} and ~\ref{sec:keepouttask}).}
\end{figure}

\label{sec:observatory}
\subsubsection{Observatory Object Attribute Initialization Input/Output Description}

\subsubsection*{Inputs}
\begin{itemize}
    \item
    \begin{description}
        \item[User specification] \hfill \\
        Information from simulation specification JSON file organized into a Python dictionary. If the below key: value pairs are missing from the dictionary, the Observatory object attributes will be assigned the default values listed.
        \begin{description}
            \item specs["settling\_time"] \hfill \\
            Amount of time needed for observatory to settle after a repointing in $ days $. Default value is 1.
            \item specs["thrust"] \hfill \\
            Occulter slew thrust in $ mN $. Default value is 450.
            \item specs["slewIsp"] \hfill \\
            Occulter slew specific impulse in $ s $. Default value is 4160.
            \item specs["sc\_mass"] \hfill \\
            Occulter (maneuvering spacecraft) initial wet mass in $ kg $. Default value is 6000.
            \item specs["dryMass"] \hfill \\
            Occulter (maneuvering spacecraft) dry mass in $ kg $. Default value is 3400.
            \item specs["coMass"] \hfill \\
            Telescope (or non-maneuvering spacecraft) mass in $ kg $. Default value is 5800.
            \item specs["occulterSep"] \hfill \\
            Occulter-telescope distance in $ km $. Default value is 55000.
            \item specs["skIsp"] \hfill \\
            Specific impulse for station keeping in $ s $. Default value is 220.
            \item specs["defburnPortion"] \hfill \\
            Default burn portion for slewing. Default value is 0.05
        \end{description}
    \end{description}
\end{itemize}

\subsubsection*{Outputs}
\begin{itemize}
    \item
    \begin{description}
        \item[Observatory.settling\_time] \hfill \\
        Amount of time needed for observatory to settle after a repointing (astropy Quantity object initially set in days)
        \item[Observatory.thrust] \hfill \\
        Occulter slew thrust (astropy Quantity object initially set in $ mN $)
        \item[Observatory.slewIsp] \hfill \\
        Occulter slew specific impulse (astropy Quantity object initially set in $ s $)
        \item[Observatory.sc\_mass] \hfill \\
        Occulter (maneuvering spacecraft) initial wet mass (astropy Quantity object initially set in $ kg $)
        \item[Observatory.dryMass] \hfill \\
        Occulter (maneuvering spacecraft) dry mass (astropy Quantity object initially set in $ kg $)
        \item[Observatory.coMass] \hfill \\
        Telescope (or non-maneuvering spacecraft) mass (astropy Quantity object initially set in $ kg $)
        \item[Observatory.kogood] \hfill \\
        1D NumPy ndarray of Boolean values where True is a target unobstructed and observable in the keepout zone. Initialized to an empty array. This attribute is updated to the current mission time through the keepout task (see \ref{sec:keepouttask}).
        \item[Observatory.r\_sc] \hfill \\
        Observatory orbit position in HE reference frame. Initialized to NumPy ndarray as numpy.array([0., 0., 0.]) and associated with astropy Quantity object in $ km $. This attribute is updated to the orbital position of the observatory at the current mission time through the orbit task (see \ref{sec:orbittask}).
        \item[Observatory.occulterSep] \hfill \\
        Occulter-telescope distance (astropy Quantity object initially set in $ km $)
        \item[Observatory.skIsp] \hfill \\
        Specific impulse for station keeping (astropy Quantity object initially set in $ s $)
        \item[Observatory.defburnPortion] \hfill \\
        Default burn portion for slewing
        \item[Observatory.currentSep] \hfill \\
        Current occulter separation (astropy Quantity object initially set in $ km $
        \item[Observatory.flowRate] \hfill \\
        Slew flow rate derived from Observatory.thrust and Observatory.slewIsp (astropy Quantity object initially set in $ kg/day $)
        
    \end{description}
\end{itemize}

\subsubsection{orbit Task Input/Output Description} \label{sec:orbittask}
The \verb+orbit+ task finds the heliocentric equatorial position vector of the observatory spacecraft.

\subsubsection*{Inputs}
\begin{itemize}
    \item
    \begin{description}
        \item[time] \hfill \\
        astropy \href{http://astropy.readthedocs.org/en/latest/time/index.html}{Time object} which may be \verb+TimeKeeping.currenttimeAbs+ from Time Keeping module see \ref{sec:currenttime} for definition
    \end{description}
\end{itemize}

\subsubsection*{Outputs}
\begin{itemize}
    \item
    \begin{description}
        \item[success] \hfill \\
        Boolean indicating if orbit was successfully calculated
    \end{description}
\end{itemize}

\subsubsection*{Updated Object Attributes}
\begin{itemize}
    \item
    \begin{description}
        \item[Observatory.r\_sc] \hfill \\
        Observatory orbit position in HE reference frame at current mission time (astropy Quantity object defined in $ km $)
    \end{description}
\end{itemize}

\subsubsection{keepout Task Input/Output Description} \label{sec:keepouttask} 
The \verb+keepout+ task determines which stars in the target list are observable at the given input time.

\subsubsection*{Inputs}
\begin{itemize}
    \item
    \begin{description}
        \item[time] \hfill \\
        astropy Time object which may be \verb+TimeKeeping.currenttimeAbs+ (see \ref{sec:currenttime} for definition)
        \item[targlist] \hfill \\
        Instantiated Target List object from Target List module. See \ref{sec:targetlist} for definition of available attributes
        \item[koangle] \hfill \\
        Telescope keepout angle in degrees - \verb+OpticalSystem.telescopeKeepout+
    \end{description}
\end{itemize}

\subsubsection*{Outputs}
\begin{itemize}
    \item
    \begin{description}
        \item[success] \hfill \\
        Boolean indicating if orbit was successfully calculated
    \end{description}
\end{itemize}

\subsubsection*{Updated Object Attributes}
\begin{itemize}
    \item 
    \begin{description}
        \item[Observatory.kogood] \hfill \\
        1D NumPy ndarray of Boolean values for each target at given time where True is a target unobstructed in the keepout zone and False is a target unobservable due to obstructions in the keepout zone
    \end{description}
\end{itemize}

% TIME KEEPING 

\subsection{Time Keeping} \label{sec:time}
The Time Keeping module is responsible for keeping track of the current mission time.  It encodes only the mission start time, the mission duration, and the current time within a simulation.  All functions in all modules requiring knowledge of the current time call functions or access parameters implemented within the Time module.  Internal encoding of time is implemented as the time from mission start (measured in days).  The Time Keeping module also provides functionality for converting between this time measure and standard measures such as Julian Day Number and UTC time.
  
The Time Keeping module contains the \verb+update_times+ and \verb+duty_cycle+ tasks.  These task updates the mission time during a survey simulation.  The duty cycle determines when during the mission timeline the observatory is allowed to perform planet-finding operations.  The duty cycle function takes the current mission time as input and outputs the next available time when exoplanet observations may begin or resume, along with the duration of the observational period. The outputs of this task are used in the Survey Simulation module to determine when and how long exoplanet finding and characterization observations occur.  The inputs and updated attributes for the Time Keeping tasks are depicted in Fig. ~\ref{fig:timekeepingmodule}.

\begin{figure}[ht]
    \begin{center}
        \begin{tabular}{c}
             \includegraphics[width=\textwidth]{TimeKeepingTasks}
        \end{tabular}
    \end{center}
    \caption{\label{fig:timekeepingmodule} Depiction of Time Keeping module task including input and updated attributes (see ~\ref{sec:updatetimestask} and ~\ref{sec:dutycycletask}).}
\end{figure}

\subsubsection{Time Keeping Object Attribute Initialization Input/Output Description}

\subsubsection*{Inputs}
\begin{itemize}
    \item
    \begin{description}
        \item[User specification] \hfill \\
        Information from simulation specification JSON file organized into a Python dictionary. If the below key: value pairs are missing from the dictionary, the Time object attributes will be assigned the default values listed.
        \begin{description}
            \item specs["missionStart"] \hfill \\
            Mission start time in $ MJD $. Default value is 60634.
            \item specs["missionLife"] \hfill \\
            Total length of mission in $ years $. Default value is 6.
            \item specs["extendedLife"] \hfill \\
            Extended mission time in $ years $. Default value is 0.
            \item specs["missionPortion"] \hfill \\
            Portion of mission time devoted to planet-finding. Default value is 1/6.
            \item specs["duration"] \hfill \\
            Duration of planet-finding operations in $ days $. Default value is 14.
            \item specs["nexttimeAvail"] \hfill \\
            Next time available for planet-finding in $ days $. Default value is 0.
        \end{description}
    \end{description}
\end{itemize}

\subsubsection*{Outputs}
\begin{itemize}
    \item
    \begin{description}
        \item[TimeKeeping.missionStart] \hfill \\
        Mission start time (astropy Time object initially defined in $ MJD $)
        \item[TimeKeeping.missionLife] \hfill \\
        Mission lifetime (astropy Quantity object initially set in $ years $)
        \item[TimeKeeping.extendedLife] \hfill \\
        Extended mission time (astropy Quantity object initially set in $ years $)
        \item[TimeKeeping.missionPortion] \hfill \\
        Portion of mission time devoted to planet-finding
        \item[TimeKeeping.duration] \hfill \\
        Duration of planet-finding operations (astropy Quantity object initially set in $ days $)
        \item[TimeKeeping.nexttimeAvail] \hfill \\
        Next time available for planet-finding (astropy Quantity object initially set in $ days $)
        \item[TimeKeeping.currenttimeNorm] \hfill \\
        Current mission time normalized so that start date is 0 (astropy Quantity object initially set in $ days $)
        \item[TimeKeeping.currenttimeAbs] \label{sec:currenttime}\hfill \\
        Current absolute mission time (astropy Time object initially defined in $ MJD $)
        \item[TimeKeeping.missionFinishNorm] \hfill \\
        Mission finish time (astropy Quantity object initially set in $ days $)
        \item[TimeKeeping.missionFinishAbs] \hfill \\
        Mission completion date (astropy Time object initially defined in $ MJD $)

    \end{description}
\end{itemize}

\subsubsection{update\_times Task Input/Output Description} \label{sec:updatetimestask}
The \verb+update_times+ task updates the relevant mission times.

\subsubsection*{Inputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[dt] \hfill \\
        Time increment (astropy Quantity object with units of time)
    \end{description}
\end{itemize}

\subsubsection*{Updated Object Attributes}
\begin{itemize}
    \item 
    \begin{description}
        \item[TimeKeeping.currenttimeNorm] \hfill \\
        Current mission time normalized so that start date is 0 (astropy Quantity object with units of time)
        \item[TimeKeeping.currenttimeAbs] \hfill \\
        Current absolute mission time (astropy Time object)
    \end{description}
\end{itemize}

\subsubsection{duty\_cycle Task Input/Output Description} \label{sec:dutycycletask}
The \verb+duty_cycle+ task updates the available time and duration for planet-finding operations.

\subsubsection*{Inputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[currenttime] \hfill \\
        Current time in mission simulation (astropy Quantity object with units of time often \verb+TimeKeeping.currenttimeNorm+)
    \end{description}
\end{itemize}

\subsubsection*{Outputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[nexttime] \hfill \\
        Next available time for planet-finding (astropy Quantity object with units of time)
    \end{description}
\end{itemize}

\subsubsection*{Updated Object Attributes}
\begin{itemize}
    \item 
    \begin{description}
        \item[TimeKeeping.nexttimeAvail] \hfill \\
        Next time available for planet-finding (astropy Quantity object with units of time)
        \item[TimeKeeping.duration] \hfill \\
        Duration of planet-finding operations (astropy Quantity object with units of time)
    \end{description}
\end{itemize}

% POST-PROCESSING

\subsection{Post-Processing}\label{sec:postprocessing}
The Post-Processing module encodes the effects of post-processing on the data gathered in a simulated observation, and the effects on the final contrast of the simulation.  The Post-Processing module is also responsible for determining whether a planet detection has occurred for a given observation, returning one of four possible states---true positive (real detection), false positive (false alarm), true negative (no detection when no planet is present) and false negative (missed detection).  These can be generated based solely on statistical modeling or by processing simulated images.

The Post-Processing module contains the \verb+det_occur+ task.  This task determines if a planet detection occurs for a given observation.  The inputs and outputs for this task are depicted in Fig. ~\ref{fig:postprocessingmodule}.

\begin{figure}[ht]
    \begin{center}
        \begin{tabular}{c}
             \includegraphics[width=0.8\textwidth]{PostTasks}
        \end{tabular}
    \end{center}
    \caption{\label{fig:postprocessingmodule} Depiction of Post-Processing module task including inputs and outputs (see ~\ref{sec:detoccurtask}).}
\end{figure}

\subsubsection{Post-Processing Object Attribute Initialization Input/Output Description}
\subsubsection*{Inputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[User specification] \hfill \\
        Information from simulation specification JSON file organized into a Python dictionary. If the below key: value pairs are missing from the dictionary, the Time object attributes will be assigned the default values listed.
        \begin{description}
            \item specs["FAP"] \hfill \\
            Detection false alarm probability. Default value is 0.01/1000.
            \item specs["MDP"] \hfill \\
            Missed detection probability. Default value is 0.001.
        \end{description}
    \end{description}
\end{itemize}

\subsubsection*{Outputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[PostProcessing.FAP] \hfill \\
        Detection false alarm probability
        \item[PostProcessing.MDP] \hfill \\
        Missed detection probability
    \end{description}
\end{itemize}

\subsubsection{det\_occur Task Input/Output Description} \label{sec:detoccurtask}
The \verb+det_occur+ task determines if a planet detection has occurred.

\subsubsection*{Inputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[observationPossible] \hfill \\
        1D NumPy ndarray of booleans signifying if a planet in the system being observed is observable
    \end{description}
\end{itemize}

\subsubsection*{Outputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[FA] \hfill \\
        Boolean where True means False Alarm
        \item[DET] \hfill \\
        Boolean where True means DETection
        \item[MD] \hfill \\
        Boolean where True means Missed Detection
        \item[NULL] \hfill \\
        Boolean where True means Null Detection
    \end{description}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SIMULATION MODULES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Simulation Modules}
The simulation modules include Completeness, Target List, Simulated Universe, Survey Simulation and Survey Ensemble. These modules perform tasks which require inputs from one or more input modules as well as calling function implementations in other simulation modules.

% COMPLETENESS

\subsection{Completeness}\label{sec:completeness}
The Completeness module takes in information from the Planet Population module to determine initial completeness and update completeness values for target list stars when called upon.

The Completeness module contains the following tasks: \verb+target_completeness+ and \verb+completeness_update+. \verb+target_completeness+ generates initial completeness values for each star in the target list (see ~\ref{sec:targetcompletenesstask}). \verb+completeness_update+ updates the completeness values following an observation (see ~\ref{sec:completenessupdatetask}).

\subsubsection{Completeness Object Attribute Initialization Input/Output Description}

\subsubsection*{Input}
\begin{itemize}
    \item 
    \begin{description}
        \item[User specification] \hfill \\
        Information from simulation specification JSON file organized into a Python dictionary. If the below key: value pairs are missing from the dictionary, the Completeness object attributes will be assigned the default values listed.
        \begin{description}
            \item specs["minComp"] \hfill \\
            Minimum completeness level for detection
        \end{description}
        \item[PlanetPopulation] \hfill \\
        Output of Planet Population module (see \ref{sec:planetpopulation})
    \end{description}
    
\end{itemize}

\subsubsection*{Output}
\begin{itemize}
    \item 
    \begin{description}
        \item[Completeness.PlanetPopulation] \hfill \\
        Output of Planet Population module (see ~\ref{sec:planetpopulation})
        \item[Completeness.minComp] \hfill \\
        Minimum completeness level for detection
    \end{description}
\end{itemize}

\subsubsection{target\_completeness Task Input/Output Description}
\label{sec:targetcompletenesstask}
The \verb+target_completeness+ task generates completeness values for each star in the target list.

\subsubsection*{Inputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[targlist] \hfill \\
        Instantiated Target List object from Target List module see ~\ref{sec:targetlist} for definition of functionality and attributes
    \end{description}
\end{itemize}

\subsubsection*{Outputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[comp0] \hfill \\
        1D NumPy ndarray containing completeness values for each star in the target list
    \end{description}
\end{itemize}

\subsubsection{completeness\_update Task Input/Output Description}
\label{sec:completenessupdatetask}
The \verb+completeness_update+ task updates the completeness values for each star in the target list following an observation.

\subsubsection*{Inputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[s\_ind] \hfill \\
        index of star in target list just observed
        \item[targlist] \hfill \\
        Instantiated Target List object from Target List module see ~\ref{sec:targetlist} for definition of functionality and attributes
        \item[obsbegin] \hfill \\
        Mission time when the observation of \verb+s_ind+ began (astropy Quantity object with units of time)
        \item[obsend] \hfill \\
        Mission time when the observation of \verb+s_ind+ ended (astropy Quantity object with units of time)
        \item[nexttime] \hfill \\
        Mission time of next observational period (astropy Quantity object with units of time)
    \end{description}
\end{itemize}

\subsubsection*{Output}
\begin{itemize}
    \item 
    \begin{description}
        \item[comp0] \hfill \\
        1D NumPy ndarray of updated completeness values for each star in the target list
    \end{description}
\end{itemize}

% TARGET LIST

\subsection{Target List}
The Target List module takes in information from the Optical System, Star Catalog, Planet Population, and Observatory input modules and Completeness simulation module to generate the target list for the simulated survey.  This list can either contain all of the targets where a planet with specified parameter ranges could be observed or a list of pre-determined targets such as in the case of a mission which only seeks to observe stars where planets are known to exist from previous surveys.  The final target list encodes all of the same information as is provided by the Star Catalog module.

\label{sec:targetlist}
\subsubsection{Target List Object Attribute Initialization Input/Output Description}
\subsubsection*{Inputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[User specification] \hfill \\
        Information from simulation specification JSON file organized into a Python dictionary. If key: value pairs are missing from the dictionary, the Target List object attributes will be assigned the default values.
        \item[StarCatalog] \hfill \\
        Output of Star Catalog module (see \ref{sec:starcatalog})
        \item[OpticalSystem] \hfill \\
        Output of Optical System module (see \ref{sec:opticalsystem})
        \item[PlanetPopulation] \hfill \\
        Output of Planet Population module (see \ref{sec:planetpopulation})
        \item[ZodiacalLight] \hfill \\
        Output of Zodiacal Light module (see \ref{sec:zodiacallight})
        \item[Completeness] \hfill \\
        Output of Completeness module (see \ref{sec:completeness})
    \end{description}
\end{itemize}

\subsubsection*{Outputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[TargetList.(StarCatalog values)] \hfill \\
        Mission specific filtered star catalog values from Star Catalog module (see \ref{sec:starcatalog})
        \item[TargetList.OpticalSystem] \hfill \\
        Output of Optical System module (see \ref{sec:opticalsystem})
        \item[TargetList.PlanetPopulation] \hfill \\
        Output of Planet Population module (see \ref{sec:planetpopulation})
        \item[TargetList.ZodiacalLight] \hfill \\
        Output of Zodiacal Light module (see \ref{sec:zodiacallight})
        \item[TargetList.Completeness] \hfill \\
        Output of Completeness module (see \ref{sec:completeness})
        \item[TargetList.maxintTime] \hfill \\
        1D NumPy ndarray of maximum integration time for each target star found from \verb+OpticalSystem.calc_maxintTime+ ~\ref{sec:calcmaxintTimetask} (astropy Quantity object with units of time)
        \item[TargetList.comp0] \hfill \\
        1D NumPy ndarray of completeness value for each target star found from \verb+Completeness.target_completeness+ ~\ref{sec:targetcompletenesstask}
        \item[TargetList.MsEst] \hfill \\
        Approximate stellar mass in $ M_{sun} $
        \item[TargetList.MsTrue] \hfill \\
        Stellar mass with an error component included in $ M_{sun} $
    \end{description}
\end{itemize}

% SIMULATED UNIVERSE 

\subsection{Simulated Universe} \label{sec:simulateduniverse}
The Simulated Universe module takes as input the outputs of the Target List simulation module to create a synthetic universe composed of the systems in the target list.  For each target, a planetary system is generated based on the statistics encoded in the Planet Population module, so that the overall planet occurrence and multiplicity rates are consistent with the provided distribution functions.  Physical parameters for each planet are similarly sampled from the input density functions.  This universe is encoded as a list where each entry corresponds to one element of the target list, and where the list entries are arrays of planet physical parameters.  In cases of empty planetary systems, the corresponding list entry contains a null array.

The Simulated Universe module also takes as input the Planet Physical Model module instance, so that it can return the specific spectra due to every simulated planet at an arbitrary observation time throughout the mission simulation.

The Simulated Universe module contains the following tasks: \verb+planet_to_star+, \verb+planet_a+, \verb+planet_e+, \verb+planet_w+, \verb+planet_O+, \verb+planet_radii+, \verb+planet_masses+, \verb+planet_albedos+, \verb+planet_inclinations+, \verb+planet_pos_vel+, and \verb+prop_system+.  \verb+planet_pos_vel+ finds initial position and velocity vectors for each planet (see ~\ref{sec:planetposveltask}).  \verb+prop_system+ propagates planet position and velocity vectors in time (see ~\ref{sec:propsystemtask}).  The rest of the tasks assign orbital or physical quantities to each planet (see \ref{sec:planettostartask}, \ref{sec:planetatask}, \ref{sec:planetetask}, \ref{sec:planetwtask}, \ref{sec:planetOtask}, \ref{sec:planetmassestask}, \ref{sec:planetradiitask}, \ref{sec:planetalbedostask}, and \ref{sec:planetinclinationstask}. The inputs and outputs for these tasks are depicted in Fig. ~\ref{fig:simulateduniversemodule}.

\begin{figure}[ht]
    \begin{center}
        \begin{tabular}{c}
             \includegraphics[width=\textwidth]{SimulatedUniverseTasks}
        \end{tabular}
    \end{center}
    \caption{\label{fig:simulateduniversemodule} Depiction of Simulated Universe module tasks including inputs and outputs (see \ref{sec:planettostartask}, \ref{sec:planetatask}, \ref{sec:planetetask}, \ref{sec:planetwtask}, \ref{sec:planetOtask}, \ref{sec:planetmassestask}, \ref{sec:planetradiitask}, \ref{sec:planetposveltask}, \ref{sec:planetalbedostask}, \ref{sec:planetinclinationstask}, and \ref{sec:propsystemtask}).}
\end{figure}

\subsubsection{Simulated Universe Object Attribute Initialization Input/Output Description}
\subsubsection*{Inputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[User specification] \hfill \\
        Information from simulation specification JSON file organized into a Python dictionary. If the below key: value pairs are missing from the dictionary, the Simulated Universe object attributes will be assigned the default values listed.
        \item[OpticalSystem] \hfill \\
        Output of Optical System module inherited from Target List module (see \ref{sec:opticalsystem})
        \item[PlanetPopulation] \hfill \\
        Output of Planet Population module inherited from Target List module (see \ref{sec:planetpopulation})
        \item[ZodiacalLight] \hfill \\
        Output of Zodiacal Light module inherited from Target List module (see \ref{sec:zodiacallight})
        \item[Completeness] \hfill \\
        Output of Completeness module inherited from Target List module (see \ref{sec:completeness})
        \item[TargetList] \hfill \\
        Output of Target List module given by above specs["targlistname"] (see \ref{sec:targetlist})
        \item[PlanetPhysicalModel] \hfill \\
        Output of Planet Physical Model module (see \ref{sec:planetphysicalmodel})
    \end{description}
\end{itemize}

\subsubsection*{Outputs}
\begin{itemize}
    \item
    \begin{description}
        \item[SimulatedUniverse.OpticalSystem] \hfill \\
        Output of Optical System module (see \ref{sec:opticalsystem})
        \item[SimulatedUniverse.pop] \hfill \\
        Output of Planet Population module (see \ref{sec:planetpopulation})
        \item[SimulatedUniverse.ZodiacalLight] \hfill \\
        Output of Zodiacal Light module (see \ref{sec:zodiacallight})
        \item[SimulatedUniverse.Completeness] \hfill \\
        Output of Completeness module (see \ref{sec:completeness})
        \item[SimulatedUniverse.TargetList] \hfill \\
        Output of Target List module (see \ref{sec:targetlist})
        \item[SimulatedUniverse.PlanetPhysicalModel] \hfill \\
        Output of Planet Physical Model module (see \ref{sec:planetphysicalmodel})
        \item[SimulatedUniverse.planInds] \hfill \\
        1D NumPy ndarray containing indices (referenced to exoplanet list) mapping each planet to its star determined from \verb+planet_to_star()+ ~\ref{sec:planettostartask}
        \item[SimulatedUniverse.nPlans] \hfill \\
        Number of planets (determined from \verb+len(SimulatedUniverse.planInds)+)
        \item[SimulatedUniverse.sysInds] \hfill \\
        1D NumPy ndarray containing indices (referenced to target star list) of target stars with planets
        \item[SimulatedUniverse.a] \hfill \\
        1D NumPy ndarray containing semi-major axis for each planet determined from \verb+planet_a()+ ~\ref{sec:planetatask}
        \item[SimulatedUniverse.e] \hfill \\
        1D NumPy ndarray containing eccentricity values for each planet determined from \verb+planet_e()+ ~\ref{sec:planetetask}
        \item[SimulatedUniverse.w] \hfill \\
        1D NumPy ndarray containing argument of perigee in degrees for each planet determined from \verb+planet_w()+ ~\ref{sec:planetwtask}
        \item[SimulatedUniverse.O] \hfill \\
        1D NumPy ndarray containing right ascension of the ascending node in degrees for each planet determined from \verb+planet_O()+ ~\ref{sec:planetOtask}
        \item[SimulatedUniverse.Mp] \hfill \\
        1D NumPy ndarray containing masses of each planet determined from \verb+planet_masses()+ ~\ref{sec:planetmassestask}
        \item[SimulatedUniverse.Rp] \hfill \\
        1D NumPy ndarray containing radii of each planet determined from \verb+planet_radii()+ ~\ref{sec:planetradiitask}
        \item[SimulatedUniverse.r] \hfill \\
        1D NumPy ndarray containing planet position vectors relative to host stars determined from \verb+planet_pos_vel()+ ~\ref{sec:planetposveltask}
        \item[SimulatedUniverse.v] \hfill \\
        1D NumPy ndarray containing planet velocity vectors relative to host stars determined from \verb+planet_pos_vel()+ ~\ref{sec:planetposveltask}
        \item[SimulatedUniverse.p] \hfill \\
        1D NumPy ndarray containing planet geometric albedos determined from \verb+planet_albedos()+ ~\ref{sec:planetalbedostask}
        \item[SimulatedUniverse.I] \hfill \\
        1D NumPy ndarray containing list of inclination of planetary systems in degrees determined from \verb+planet_inclinations()+ ~\ref{sec:planetinclinationstask}
        \item[SimulatedUniverse.fzodicurr] \hfill \\
        1D NumPy ndarray containing list of exozodi levels for systems with planets determined from \verb+ZodiacalLight.fzodi+ ~\ref{sec:fzoditask}
    \end{description}
\end{itemize}

\subsubsection{planet\_to\_star Task Input/Output Description} \label{sec:planettostartask}
The \verb+planet_to_star+ task determines how many planets belong to each star in the target list.  It returns a 1D NumPy ndarray containing the indices of the target star to which each planet belongs.  The length of the ndarray is the total number of planets in the simulated universe.

\subsubsection*{Inputs}
This task does not take any explicit inputs.  It uses the inherited Target List and Planet Population objects.

\subsubsection*{Outputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[planSys] \hfill \\
        1D NumPy ndarray containing the indices of each target star to which each planet (each element of the array) belongs
    \end{description}
\end{itemize}

\subsubsection{planet\_a Task Input/Output Description} \label{sec:planetatask}
The \verb+planet_a+ task assigns each planet a semi-major axis with astropy Quantity units of distance (AU).  The prototype samples the probablity density function \verb+PlanetPopulation.semi_axis(x)+ ~\ref{sec:pdfs} and returns appropriate output.

\subsubsection*{Inputs}
This task does not take any explicit inputs.  It uses the inherited Planet Population object and total number of planets (\verb+SimulatedUniverse.nPlans+).

\subsubsection*{Outputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[a] \hfill \\
        1D NumPy ndarray containing semi-major axis for each planet (astropy Quantity object with units of $ AU $)
    \end{description}
\end{itemize}

\subsubsection{planet\_e Task Input/Output Description} \label{sec:planetetask}
The \verb+planet_e+ task assigns each planet an eccentricity value. The prototype samples the probablity density function \verb+PlanetPopulation.eccentricity(x)+ ~\ref{sec:pdfs} and returns appropriate output.

\subsubsection*{Inputs}
This task does not take any explicit inputs.  It uses the inherited Planet Population object and total number of planets (\verb+SimulatedUniverse.nPlans+).

\subsubsection*{Outputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[e] \hfill \\
        1D NumPy ndarray containing eccentricity for each planet
    \end{description}
\end{itemize}

\subsubsection{planet\_w Task Input/Output Description} \label{sec:planetwtask}
The \verb+planet_w+ task assigns each planet argument of perigee in degrees. The prototype samples the probablity density function \verb+PlanetPopulation.arg_perigee(x)+ ~\ref{sec:pdfs} and returns appropriate output.

\subsubsection*{Inputs}
This task does not take any explicit inputs.  It uses the inherited Planet Population object and total number of planets (\verb+SimulatedUniverse.nPlans+).

\subsubsection*{Outputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[w] \hfill \\
        1D NumPy ndarray containing argument of perigee in degrees for each planet
    \end{description}
\end{itemize}

\subsubsection{planet\_O Task Input/Output Description} \label{sec:planetOtask}
The \verb+planet_O+ task assigns each planet right ascension of the ascending node in degrees. The prototype samples the probablity density function \verb+PlanetPopulation.RAAN(x)+ ~\ref{sec:pdfs} and returns appropriate output.

\subsubsection*{Inputs}
This task does not take any explicit inputs.  It uses the inherited Planet Population object and total number of planets (\verb+SimulatedUniverse.nPlans+).

\subsubsection*{Outputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[O] \hfill \\
        1D NumPy ndarray containing right ascension of the ascending node in degrees for each planet
    \end{description}
\end{itemize}

\subsubsection{planet\_masses Task Input/Output Description} \label{sec:planetmassestask}
The \verb+planet_masses+ task assigns each planet mass with astropy Quantity units of mass (default is $ kg $). The prototype samples the probablity density function \verb+PlanetPopulation.mass(x)+ ~\ref{sec:pdfs} and returns appropriate output.

\subsubsection*{Inputs}
This task does not take any explicit inputs.  It uses the inherited Planet Population object and total number of planets (\verb+SimulatedUniverse.nPlans+).

\subsubsection*{Outputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[M] \hfill \\
        1D NumPy ndarray containing mass for each planet (astropy Quantity object with default units of $ kg $)
    \end{description}
\end{itemize}

\subsubsection{planet\_radii Task Input/Output Description} \label{sec:planetradiitask}
The \verb+planet_radii+ task assigns each planet a radius with astropy Quantity units of distance (default is $ km $). The prototype samples the probablity density function \verb+PlanetPopulation.radius(x)+ ~\ref{sec:pdfs} and returns appropriate output.

\subsubsection*{Inputs}
This task does not take any explicit inputs.  It uses the inherited Planet Population object and total number of planets (\verb+SimulatedUniverse.nPlans+).

\subsubsection*{Outputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[Rp] \hfill \\
        1D NumPy ndarray containing radius for each planet (astropy Quantity object with default units of $ km $)
    \end{description}
\end{itemize}

\subsubsection{planet\_pos\_vel Task Input/Output Description} \label{sec:planetposveltask}
The \verb+planet_pos_vel+ task assigns each planet an initial position and velocity vector with appropriate astropy Quantity units attached.

\subsubsection*{Inputs}
This task does not take any explicit inputs.  It uses the following attributes assigned before calling this task:
\begin{itemize}
    \item \verb+SimulatedUniverse.a+
    \item \verb+SimulatedUniverse.e+
    \item \verb+SimulatedUniverse.Mp+
    \item \verb+SimulatedUniverse.I+
    \item \verb+SimulatedUniverse.w+
    \item \verb+SimulatedUniverse.O+
\end{itemize}

\subsubsection*{Outputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[r] \hfill \\
        NumPy ndarray containing initial position vector for each planet (astropy Quantity object with default units of $ km $)
        \item[v] \hfill \\
        NumPy ndarray containing initial velocity vector for each planet (astropy Quantity object with default units of $ km/s $)
    \end{description}
\end{itemize}

\subsubsection{planet\_albedos Task Input/Output Description} \label{sec:planetalbedostask}
The \verb+planet_albedos+ task assigns each planet a geometric albedo value. The prototype samples the probablity density function \verb+PlanetPopulation.albedo(x)+ ~\ref{sec:pdfs} and returns appropriate output.

\subsubsection*{Inputs}
This task does not take any explicit inputs.  It uses the inherited Planet Population object and total number of planets (\verb+SimulatedUniverse.nPlans+).

\subsubsection*{Outputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[p] \hfill \\
        1D NumPy ndarray containing geometric albedo for each planet 
    \end{description}
\end{itemize}

\subsubsection{planet\_inclinations Task Input/Output Description} \label{sec:planetinclinationstask}
The \verb+planet_inclinations+ task assigns each planet an inclination in degrees. The prototype samples the probablity density function \verb+PlanetPopulation.inclination(x)+ ~\ref{sec:pdfs} and returns appropriate output.

\subsubsection*{Inputs}
This task does not take any explicit inputs.  It uses the inherited Planet Population object and total number of planets (\verb+SimulatedUniverse.nPlans+).

\subsubsection*{Outputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[I] \hfill \\
        1D NumPy ndarray containing inclination for each planet in degrees 
    \end{description}
\end{itemize}

\subsubsection{prop\_system Task Input/Output Description} \label{sec:propsystemtask}
The \verb+prop_system+ task propagates planet state vectors (position and velocity) in time.

\subsubsection*{Inputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[r] \hfill \\
        NumPy ndarray containing current planet position vectors relative to host star (astropy Quantity object with units of distance)
        \item[v] \hfill \\
        NumPy ndarray containing current planet velocity vectors relative to host star (astropy Quantity object with units of distance/time)
        \item[Mp] \hfill \\
        1D NumPy ndarray containing planet masses (astropy Quantity object with units of mass)
        \item[Ms] \hfill \\
        1D NumPy ndarray containing target star mass in $ M_{sun} $
        \item[dt] \hfill \\
        Time increment to propagate system (astropy Quantity object with units of time)
    \end{description}
\end{itemize}

\subsubsection*{Outputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[rnew] \hfill \\
        NumPy ndarray of propagated position vectors relative to host star (astropy Quantity object with units of distance)
        \item[vnew] \hfill \\
        NumPy ndarray of propagated velocity vectors relative to host star (astropy Quantity object with units of distance/time)
    \end{description}
\end{itemize}

% SURVEY SIMULATION

\subsection{Survey Simulation} \label{sec:surveysim}
The Survey Simulation module takes as input the output of the Simulated Universe simulation module and the Time Keeping, and Post-Processing input modules. This is the module that performs a specific simulation based on all of the input parameters and models. This module returns the mission timeline - an ordered list of simulated observations of various targets on the target list along with their outcomes.  The output also includes an encoding of the final state of the simulated universe (so that a subsequent simulation can start from where a previous simulation left off) and the final state of the observatory definition (so that post-simulation analysis can determine the percentage of volatiles expended, and other engineering metrics).

Survey Simulation TASKS: 
\verb+run_sim()+ - perform survey simulation ~\ref{sec:runsimtask}

Survey Simulation SUBTASKS:
\verb+initial_target()+ - find initial target star ~\ref{sec:initialtargettask}

\verb+observation_detection(pInds, s_ind, DRM, planPosTime)+ - finds if planet detections are possible and returns relevant information ~\ref{sec:observationdetectiontask}

\verb+det_data(s, dMag, Ip, DRM, FA, DET, MD, s_ind, pInds, observationPossible, observed)+ - determines detection status ~\ref{sec:detdatatask}

\verb+observation_characterization(observationPossible, pInds, s_ind, spectra, s, Ip, DRM, FA, t_int)+ - finds if characterizations are possible and returns relevant information ~\ref{sec:observationcharacterizationtask}

\verb+next_target(s_ind, revisit_list, extended_list, DRM)+ - find next target (scheduler) ~\ref{sec:nexttargettask}

\subsubsection{Survey Simulation Object Attribute Initialization Input/Output Description}
\subsubsection*{Inputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[User specification] \hfill \\
        Information from simulation specification JSON file organized into a Python dictionary. If the below key: value pairs are missing from the dictionary, the Survey Simulation object attributes will be assigned the default values listed.
        \item[OpticalSystem] \hfill \\
        Output of Optical System module inherited from Simulated Universe module (see \ref{sec:opticalsystem})
        \item[PlanetPopulation] \hfill \\
        Output of Planet Population module inherited from Simulated Universe module (see \ref{sec:planetpopulation})
        \item[ZodiacalLight] \hfill \\
        Output of Zodiacal Light module inherited from Simulated Universe module (see \ref{sec:zodiacallight})
        \item[Completeness] \hfill \\
        Output of Completeness module inherited from Simulated Universe module (see \ref{sec:completeness})
        \item[TargetList] \hfill \\
        Output of Target List module inherited from Simulated Universe module (see \ref{sec:targetlist})
        \item[PlanetPhysicalModel] \hfill \\
        Output of Planet Physical Model module inherited from Simulated Universe module (see \ref{sec:planetphysicalmodel})
        \item[SimulatedUniverse] \hfill \\
        Output of Simulated Universe module (see \ref{sec:simulateduniverse})
        \item[Observatory] \hfill \\
        Output of Observatory module (see \ref{sec:observatory})
        \item[TimeKeeping] \hfill \\
        Output of Time Keeping module (see \ref{sec:time})
        \item[PostProcessing] \hfill \\
        Output of Post-Processing module (see \ref{sec:postprocessing})
    \end{description}
\end{itemize}

\subsubsection*{Outputs}
\begin{itemize}
    \item
    \begin{description}
        \item[SurveySimulation.OpticalSystem] \hfill \\
        Output of Optical System module (see \ref{sec:opticalsystem})
        \item[SurveySimulation.PlanetPopulation] \hfill \\
        Output of Planet Population module (see \ref{sec:planetpopulation})
        \item[SurveySimulation.ZodiacalLight] \hfill \\
        Output of Zodiacal Light module (see \ref{sec:zodiacallight})
        \item[SurveySimulation.Completeness] \hfill \\
        Output of Completeness module (see \ref{sec:completeness})
        \item[SurveySimulation.TargetList] \hfill \\
        Output of Target List module (see \ref{sec:targetlist})
        \item[SurveySimulation.PlanetPhysicalModel] \hfill \\
        Output of Planet Physical Model module (see \ref{sec:planetphysicalmodel})
        \item[SurveySimulation.SimulatedUniverse] \hfill \\
        Output of Simulated Universe module (see \ref{sec:simulateduniverse})
        \item[SurveySimulation.Observatory] \hfill \\
        Output of Observatory module (see \ref{sec:observatory})
        \item[SurveySimulation.TimeKeeping] \hfill \\
        Output of Time Keeping module (see \ref{sec:time})
        \item[SurveySimulation.PostProcessing] \hfill \\
        Output of Post-Processing module (see \ref{sec:postprocessing})
        \item[SurveySimulation.DRM] \hfill \\
        Contains the results of survey simulation
    \end{description}
\end{itemize}

\subsubsection{run\_sim Task Input/Output Description} \label{sec:runsimtask}
The \verb+run_sim+ task performs the survey simulation and populates the results in \verb+SurveySimulation.DRM+.

\subsubsection*{Inputs}
This task does not take any explicit inputs.  It uses the inherited modules to generate a survey simulation.

\subsubsection*{Updated Object Attributes}
\begin{itemize}
    \item 
    \begin{description}
        \item[SurveySimulation.DRM] \hfill \\
        Python list where each entry contains a dictionary of survey simulation results for each observation.  The dictionary may include the following key:value pairs (from the prototype):
        \begin{description}
            \item['target\_ind'] \hfill \\
            Index of star in target list observed
            \item['arrival\_time'] \hfill \\
            Days since mission start when observation begins
            \item['sc\_mass'] \hfill \\
            Maneuvering spacecraft mass (if simulating an occulter system)
            \item['dF\_lateral'] \hfill \\
            Lateral disturbance force on occulter in $ N $ if simulating an occulter system
            \item['dF\_axial'] \hfill \\
            Axial disturbance force on occulter in $ N $ if simulating an occulter system
            \item['det\_dV'] \hfill \\
            Detection station-keeping $\Delta$V in $ m/s $ if simulating an occulter system
            \item['det\_mass\_used'] \hfill \\
            Detection station-keeping fuel mass used in $ kg $ if simulating an occulter system
            \item['det\_int\_time'] \hfill \\
            Detection integration time in $ days $
            \item['det\_status'] \hfill \\
            Integer or list where
            \begin{itemize}
                \item 1 = detection
                \item 0 = null detection
                \item -1 = missed detection
                \item -2 = false alarm
            \end{itemize}
            \item['det\_WA'] \hfill \\
            Detection WA in $ milliarcseconds $
            \item['det\_dMag'] \hfill \\
            Detection $ \Delta $mag
            \item['char\_1\_time'] \hfill \\
            Characterization integration time in $ days $
            \item['char\_1\_dV'] \hfill \\
            Characterization station-keeping $\Delta$V in $ m/s $ if simulating an occulter system
            \item['char\_1\_mass\_used'] \hfill \\
            Characterization station-keeping fuel mass used in $ kg $ if simulating an occulter system
            \item['char\_1\_success'] \hfill \\
            Characterization success where value which may be:
            \begin{itemize}
                \item 1 - successfull characterization
                \item effective wavelength found during characterization in $ nm $
            \end{itemize}
            \item['slew\_time'] \hfill \\
            Slew time to next target in $ days $ if simulating an occulter system
            \item['slew\_dV'] \hfill \\
            Slew $\Delta$V in $ m/s $ if simulating an occulter system
            \item['slew\_mass\_used'] \hfill \\
            Slew fuel mass used in $ kg $ if simulating an occulter system
            \item['slew\_angle'] \hfill \\
            Slew angle to next target in $ rad $
        \end{description}
    \end{description}
\end{itemize}

\subsubsection{initial\_target Sub-task Input/Output Description} \label{sec:initialtargettask}
The \verb+initial_target+ sub-task is called from the \verb+run_sim+ task to determine the index of the initial target star in the target list.

\subsubsection*{Inputs}
This sub-task does not take any explicit inputs.  It may use any of the inherited modules to generate the initial target star index.

\subsubsection*{Outputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[s\_ind] \hfill \\
        Index of the initial target star
    \end{description}
\end{itemize}

\subsubsection{observation\_detection Sub-task Input/Output Description} \label{sec:observationdetectiontask}
The \verb+observation_detection+ sub-task is called from the \verb+run_sim+ task to determine if planets may be detected and calculate information needed later in the simulation.

\subsubsection*{Inputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[pInds] \hfill \\
        1D NumPy ndarray of indices of planets belonging to the target star (used to get relevant attributes from the \verb+SimulatedUniverse+ module)
        \item[s\_ind] \hfill \\
        Index of target star in target list
        \item[DRM] \hfill \\
        Python dictionary containing survey simulation results of current observation as key:value pairs
        \item[planPosTime] \hfill \\
        1D NumPy ndarray containing the times at which the planet positions and velocities contained in \verb+SimulatedUniverse.r+ and \verb+SimulatedUniverse.v+ are current (astropy Quantity object with units of time)
    \end{description}
\end{itemize}

\subsubsection*{Outputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[observationPossible] \hfill \\
        1D NumPy ndarray (length is number of planets in the system under observation) containing boolean values where True is an observable planet
        \item[t\_int] \hfill \\
        Integration time (astropy Quantity object with units of time)
        \item[DRM] \hfill \\
        Python dictionary containing survey simulation results of current observation as key:value pairs
        \item[s] \hfill \\
        1D NumPy ndarray (length is number of planets in the system under observation) containing apparent separation of planets (astropy Quantity object with units of distance)
        \item[dMag] \hfill \\
        1D NumPy ndarray (length is number of planets in the system under observation) containing $ \Delta $mag for each planet
        \item[Ip] \hfill \\
        1D NumPy ndarray (length is number of planets in the system under observation) containing irradiance (astropy Quantity object with units of $ \frac{1}{m^2 \cdot nm \cdot s} $)
    \end{description}
\end{itemize}

\subsubsection{det\_data Sub-task Input/Output Description} \label{sec:detdatatask}
The \verb+det_data+ sub-task is called from the \verb+run_sim+ task to assign a detection status to the dictionary of current observation results.

\subsubsection*{Inputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[s] \hfill \\
        1D NumPy array (length is number of planets in the system under observation) containing apparent separation of planets (astropy Quantity object with units of distance)
        \item[dMag] \hfill \\
        1D NumPy ndarray (length is number of planets in the system under observation) containing $ \Delta $mag for each planet
        \item[Ip] \hfill
        1D NumPy ndarray (length is number of planets in the system under observation) containing irradiance (astropy Quantity object with units of $ \frac{1}{m^2 \cdot nm \cdot s} $)
        \item[DRM] \hfill \\
        Python dictionary containing survey simulation results of current observation as key:value pairs
        \item[FA] \hfill \\
        Boolean where True is False Alarm
        \item[DET] \hfill \\
        Boolean where True is DETection
        \item[MD] \hfill \\
        Boolean where True is Missed Detection
        \item[s\_ind] \hfill \\
        Index of target star in target list
        \item[pInds] \hfill \\
        1D NumPy ndarray of indices of planets belonging to the target star (used to get relevant attributes from the \verb+SimulatedUniverse+ module)
        \item[observationPossible] \hfill \\
        1D NumPy ndarray (length is number of planets in the system under observation) containing boolean values where True is an observable planet
        \item[observed] \hfill \\
        1D NumPy ndarray which contains the number of observations for each planet in the simulated universe
    \end{description}
\end{itemize}

\subsubsection*{Outputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[s] \hfill \\
        1D NumPy array (length is number of planets in the system under observation) containing apparent separation of planets (astropy Quantity object with units of distance)
        \item[dMag] \hfill \\
        1D NumPy ndarray (length is number of planets in the system under observation) containing $ \Delta $mag for each planet
        \item[Ip] \hfill \\
        1D NumPy ndarray (length is number of planets in the system under observation) containing irradiance (astropy Quantity object with units of $ \frac{1}{m^2 \cdot nm \cdot s} $)
        \item[DRM] \hfill \\
        Python dictionary containing survey simulation results of current observation as key:value pairs
        \item[observed] \hfill \\
        1D NumPy ndarray which contains the number of observations for each planet in the simulated universe
    \end{description}
\end{itemize}

\subsubsection{observation\_characterization Sub-task Input/Output Description} \label{sec:observationcharacterizationtask}
The \verb+observation_characterization+ sub-task is called by the \verb+run_sim+ task to determine if characterizations are to be performed and calculate relevant characterization information to be used later in the observation simulation.

\subsubsection*{Inputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[observationPossible] \hfill \\
        1D NumPy ndarray (length is number of planets in the system under observation) containing boolean values where True is an observable planet
        \item[pInds] \hfill \\
        1D NumPy ndarray of indices of planets belonging to the target star (used to get relevant attributes from the \verb+SimulatedUniverse+ module)
        \item[s\_ind] \hfill \\
        Index of target star in target list
        \item[spectra] \hfill \\
        NumPy ndarray where 1 denotes spectra for a planet that has been captured, 0 denotes spectra for a planet that has not been captured
        \item[s] \hfill \\
        1D NumPy array (length is number of planets in the system under observation) containing apparent separation of planets (astropy Quantity object with units of distance)
        \item[Ip] \hfill \\
        1D NumPy ndarray (length is number of planets in the system under observation) containing irradiance (astropy Quantity object with units of $ \frac{1}{m^2 \cdot nm \cdot s} $)
        \item[DRM] \hfill \\
        Python dictionary containing survey simulation results of current observation as key:value pairs
        \item[FA] \hfill \\
        Boolean where True is False Alarm
        \item[t\_int] \hfill \\
        Integration time (astropy Quantity object with units of time)
    \end{description}
\end{itemize}

\subsubsection*{Outputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[DRM] \hfill \\
        Python dictionary containing survey simulation results of current observation as key:value pairs
        \item[FA] \hfill \\
        Boolean where True is False Alarm
        \item[spectra] \hfill \\
        NumPy ndarray where 1 denotes spectra for a planet that has been captured, 0 denotes spectra for a planet that has not been captured
    \end{description}
\end{itemize}

\subsubsection{next\_target Sub-task Input/Output Description} \label{sec:nexttargettask}
The \verb+next_target+ sub-task is called from the \verb+run_sim+ task to determine the index of the next star from the target list for observation.

\subsubsection*{Inputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[s\_ind] \hfill \\
        Index of current star from the target list
        \item[targlist] \hfill \\
        Target List module (see \ref{sec:targetlist})
        \item[revisit\_list] \hfill \\
        NumPy ndarray containing index of target star and time in days of target stars from the target list to revisit
        \item[extended\_list] \hfill \\
        1D NumPy ndarray containing the indices of stars in the target list to consider if in extended mission time
        \item[DRM] \hfill \\
        Python dictionary containing survey simulation results of current observation as key:value pairs
    \end{description}
\end{itemize}

\subsubsection*{Outputs}
\begin{itemize}
    \item 
    \begin{description}
        \item[new\_s\_ind] \hfill \\
        Index of next target star in the target list
        \item[DRM] \hfill \\
        Python dictionary containing survey simulation results of current observation as key:value pairs
    \end{description}
\end{itemize}

% SURVEY ENSEMBLE NEEDS UPDATING

\subsection{Survey Ensemble NEEDS UPDATING}
The Survey Ensemble module's only task is to run multiple simulations.  While the implementation of this module is not at all dependent on a particular mission design, it can vary to take advantage of available parallel-processing resources.  As the generation of a survey ensemble is an embarrassingly parallel task---every survey simulation is fully independent and can be run as a completely separate process---significant gains in execution time can be achieved with parallelization.  The baseline implementation of this module contains a simple looping function that executes the desired number of simulations sequentially, as well as a locally parallelized version based on IPython Parallel.

Depending on the local setup, the Survey Ensemble implementation could also potentially save time by cloning survey module objects and reinitializing only those sub-modules that have stochastic elements (i.e., the simulated universe).

Another possible implementation variation is to use the Survey Ensemble module to conduct investigations of the effects of varying any normally static parameter.  This could be done, for example, to explore the impact on yield in cases where the non-coronagraph system throughput, or elements of the propulsion system, are mischaracterized prior to launch.  This SE module implementation would overwrite the parameter of interest given in the input specification for every individual survey executed, and saving the true value of the parameter used along with the simulation output.

\end{document}

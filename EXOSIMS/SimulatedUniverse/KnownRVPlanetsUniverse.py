from EXOSIMS.Prototypes.SimulatedUniverse import SimulatedUniverse
import numpy as np
from astropy import units as u
from astropy import constants as const

class KnownRVPlanetsUniverse(SimulatedUniverse):
    """
    Simulated universe implementation inteded to work with the Known RV planet
    planetary population and target list implementations.
    
    Args: 
        \*\*specs: 
            user specified values
            
    Attributes: 

    Notes:
        
    """

    def __init__(self, **specs):

        SimulatedUniverse.__init__(self, **specs)

    def gen_planetary_systems(self,**specs):
        """
        Generate the planetary systems for the current simulated universe.
        This routine populates arrays of the orbital elements and physical 
        characteristics of all planets, and generates indexes that map from 
        planet to parent star.

        All parameters are generated by adding consistent error terms to the 
        catalog values for each planet.
        """

        # Go through the target list and pick out the planets belonging to those hosts
        starinds = np.array([])
        planinds = np.array([])
        for j,name in enumerate(self.TargetList.Name):
            tmp = np.where(self.PlanetPopulation.hostname == name)[0]
            planinds = np.hstack((planinds,tmp))
            starinds = np.hstack((starinds,[j]*len(tmp)))
            
        planinds = planinds.astype(int)
        starinds = starinds.astype(int)
        self.nPlans = len(planinds)

        # map planets to stars in standard format
        self.planInds = starinds
        self.sysInds = np.unique(self.planInds)


        #populate parameters
        self.a = self.PlanetPopulation.sma[planinds] +  np.random.normal(size=self.nPlans)*self.PlanetPopulation.smaerr[planinds]

        self.e = self.PlanetPopulation.eccentricity[planinds] + np.random.normal(size=self.nPlans)*self.PlanetPopulation.eccentricityerr[planinds]
        self.e[self.e < 0.] = 0.
        self.e[self.e > 0.9] = 0.9
 
        self.I = self.PlanetPopulation.allplanetdata['pl_orbincl'][planinds] + \
                np.random.normal(size=self.nPlans)*self.PlanetPopulation.allplanetdata['pl_orbinclerr1'][planinds] 
        self.I[self.I.mask] = self.PlanetPopulation.gen_I(len(np.where(self.I.mask)[0])).to('deg').value
        self.I = self.I.data*u.deg

        self.w = self.PlanetPopulation.gen_w(self.nPlans) 
        lper = self.PlanetPopulation.allplanetdata['pl_orblper'][planinds] + \
                np.random.normal(size=self.nPlans)*self.PlanetPopulation.allplanetdata['pl_orblpererr1'][planinds] 

        self.O = lper.data*u.deg - self.w
        self.O[np.isnan(self.O)] =  self.PlanetPopulation.gen_O(len(np.where(np.isnan(self.O))[0]))

        self.Mp = self.PlanetPopulation.mass[planinds]
        self.Rp = self.PlanetPhysicalModel.calc_radius_from_mass(self.Mp)
        self.p = self.PlanetPhysicalModel.calc_albedo_from_sma(self.a)
        
        # planet initial positions
        self.r, self.v = self.planet_pos_vel() 
        # exo-zodi levels for systems with planets
        self.fEZ = self.ZodiacalLight.fEZ(self.TargetList,self.planInds,self.I)


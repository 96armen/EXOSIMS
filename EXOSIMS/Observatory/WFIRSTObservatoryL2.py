from EXOSIMS.Observatory.WFIRSTObservatory import WFIRSTObservatory
import astropy.units as u
from astropy.time import Time
from astropy.coordinates import SkyCoord
import numpy as np
import os, inspect
import scipy.interpolate as interpolate
try:
    import cPickle as pickle
except:
    import pickle
from scipy.io import loadmat

class WFIRSTObservatoryL2(WFIRSTObservatory):
    """ WFIRST Observatory at L2 implementation. 
    Only difference between this and the WFIRSTObservatory implementation
    is the orbit method, and carrying an internal missionStartTime value,
    which should be the same as the one in TimeKeeping (necessary due to 
    orbit method interface, which calls for absolute time).
    
    Orbit is stored in pickled dictionary on disk (generated by MATLAB
    code adapted from E. Kolemen (2008).  Describes approx. 6 month halo
    which is then patched for the entire mission duration).
    """

    def __init__(self, missionStart=60634., orbit_datapath=None, **specs):
        
        # Run prototype constructor __init__ 
        WFIRSTObservatory.__init__(self,**specs)
        
        # Set own missionStart value
        self.missionStart = Time(float(missionStart), format='mjd', scale='tai')
        
        # Find and load halo orbit data
        # data is in heliocentric ecliptic coords
        # time is 2\pi = 1 sideral year
        
        if orbit_datapath is None:
            classpath = os.path.split(inspect.getfile(self.__class__))[0]
            filename = 'L2_halo_orbit_six_month.p'
            orbit_datapath = os.path.join(classpath, filename)
        if not os.path.exists(orbit_datapath):
            matname = 'L2_halo_orbit_six_month.mat'
            mat_datapath = os.path.join(classpath, matname)
            if not os.path.exists(mat_datapath):
                raise Exception("Orbit data file not found.")
            else:
                halo = loadmat(mat_datapath)
                pickle.dump(halo, open(orbit_datapath, 'wb'))
        else:
            halo = pickle.load(open(orbit_datapath, 'rb'))
        
        # unpack orbit properties wrt Sun in ecliptic frame 
        self.period_halo = halo['te'][0,0]/(2*np.pi)*u.year
        self.t_halo = halo['t'][:,0]/(2*np.pi)*u.year
        self.r_halo = halo['state'][:,0:3]*u.AU
        self.v_halo = halo['state'][:,3:6]*u.AU/u.year*(2*np.pi)
        # position wrt Earth
        self.r_halo[:,0] -= 1*u.AU
        
        # create interpolant for position (years & AU units)
        self.r_halo_interp = interpolate.interp1d(self.t_halo.value, \
                self.r_halo.value.T, kind='linear')
        # create interpolant for orbital velocity (years & AU/yr units)
        self.v_halo_interp = interpolate.interp1d(self.t_halo.value, \
                self.v_halo.value.T, kind='linear')

    def orbit(self, currentTime):
        """Finds observatory orbit position vector in heliocentric equatorial frame.
        
        This method returns the WFIRST L2 Halo orbit position vector
        in the heliocentric equatorial frame.
        
        Args:
            currentTime (astropy Time array):
                Current absolute mission time in MJD
        
        Returns:
            r_sc (astropy Quantity nx3 array):
                Observatory (spacecraft) position vector in units of km
        
        """
        
        # find time from Earth equinox and interpolated position
        equinox = Time([60575.25], format='mjd', scale='tai')
        dt = (currentTime - equinox).to('yr')
        t_halo = np.mod(dt, self.period_halo).to('yr')
        r_halo = self.r_halo_interp(t_halo.value).T*u.AU
        
        # adding Earth-Sun distance
        r_Earth = self.solarSystem_body_position(currentTime, 'Earth')
        r_Earth_norm = np.linalg.norm(r_Earth, axis=1)*r_Earth.unit
        r_halo[:,0] += r_Earth_norm
        
        # rotate into current ecliptic coord
        th = np.sign(r_Earth[:,1])*np.arccos(r_Earth[:,0]/r_Earth_norm).to('rad').value
        r_sc = np.array([np.dot(self.rot(-th[x],3), r_halo[x,:]) \
                for x in range(currentTime.size)])*r_halo.unit
        
        # find obliquity of the ecliptic
        TDB = self.cent(currentTime)
        obe = np.array(np.radians(self.obe(TDB)),ndmin=1)
        # position vector (km) in heliocentric equatorial frame
        r_sc = np.array([np.dot(self.rot(-obe[x],1), r_sc[x,:].to('km')) \
                for x in range(currentTime.size)])*u.km
        
        assert np.all(np.isfinite(r_sc)), \
                "Observatory position vector r_sc has infinite value."
        
        return r_sc

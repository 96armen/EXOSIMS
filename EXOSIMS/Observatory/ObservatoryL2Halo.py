from EXOSIMS.Prototypes.Observatory import Observatory
import astropy.units as u
from astropy.time import Time
from astropy.coordinates import SkyCoord
import numpy as np
import os, inspect
import scipy.interpolate as interpolate
try:
    import cPickle as pickle
except:
    import pickle
from scipy.io import loadmat

class ObservatoryL2Halo(Observatory):
    """ WFIRST Observatory at L2 implementation. 
    Only difference between this and the Observatory implementation
    is the orbit method, and carrying an internal equinox time value.
    
    Orbit is stored in pickled dictionary on disk (generated by MATLAB
    code adapted from E. Kolemen (2008).  Describes approx. 6 month halo
    which is then patched for the entire mission duration).
    
    """

    def __init__(self, equinox=60575.25, orbit_datapath=None, **specs):
        
        # run prototype constructor __init__ 
        Observatory.__init__(self,**specs)
        
        # set equinox value
        self.equinox = Time(np.array(equinox, ndmin=1, dtype=float),
                format='mjd', scale='tai')
        
        keysHalo = ['te','t','state','x_lpoint','mu']
        
        # find and load halo orbit data in heliocentric ecliptic frame
        if orbit_datapath is None:
            classpath = os.path.split(inspect.getfile(self.__class__))[0]
            filename = 'L2_halo_orbit_six_month.p'
            orbit_datapath = os.path.join(classpath, filename)
            
        if os.path.exists(orbit_datapath):
            halo = pickle.load(open(orbit_datapath, 'rb'))
            try:
                for x in keysHalo:
                    halo[x]
            except:
                print "Relevant keys not found, updating pickle file."
                orbit_datapath = os.path.join(classpath,'###.p')
            
        if not os.path.exists(orbit_datapath):
            orbit_datapath = os.path.join(classpath, filename)
            matname = 'L2_halo_orbit_six_month.mat'
            mat_datapath = os.path.join(classpath, matname)
            if not os.path.exists(mat_datapath):
                print mat_datapath
                raise Exception("Orbit data file not found.")
            else:
                halo = loadmat(mat_datapath)
                pickle.dump(halo, open(orbit_datapath, 'wb'))
        
        # unpack orbit properties in heliocentric ecliptic frame 
        self.mu = halo['mu'][0][0]
        self.m1 = float(1-self.mu)
        self.m2 = self.mu
        self.period_halo = halo['te'][0,0]/(2*np.pi)
        self.t_halo = halo['t'][:,0]/(2*np.pi)*u.year # 2\pi = 1 sideral year
        self.r_halo = halo['state'][:,0:3]*u.AU
        self.v_halo = halo['state'][:,3:6]*u.AU/u.year*(2*np.pi)
        # position wrt Earth
        self.r_halo[:,0] -= 1*u.AU
        
        # create interpolant for position (years & AU units)
        self.r_halo_interp = interpolate.interp1d(self.t_halo.value,
                self.r_halo.value.T, kind='linear')
        # create interpolant for orbital velocity (years & AU/yr units)
        self.v_halo_interp = interpolate.interp1d(self.t_halo.value,
                self.v_halo.value.T, kind='linear')
                
        # orbital properties used in Circular Restricted 3 Body Problem
        self.L2_dist = halo['x_lpoint'][0][0]*u.AU
        self.r_halo_L2 = halo['state'][:,0:3]*u.AU
        # position wrt L2
        self.r_halo_L2[:,0] -= self.L2_dist 
        
        # create new interpolant for CR3BP (years & AU units)
        self.r_halo_interp_L2 = interpolate.interp1d(self.t_halo.value,
                self.r_halo_L2.value.T, kind='linear')


    def orbit(self, currentTime, eclip=False):
        """Finds observatory orbit positions vector in heliocentric equatorial (default)
        or ecliptic frame for current time (MJD).
        
        This method returns the WFIRST L2 Halo orbit position vector.
        
        Args:
            currentTime (astropy Time array):
                Current absolute mission time in MJD
            eclip (boolean):
                Boolean used to switch to heliocentric ecliptic frame. Defaults to 
                False, corresponding to heliocentric equatorial frame.
        
        Returns:
            r_obs (astropy Quantity nx3 array):
                Observatory orbit positions vector in heliocentric equatorial (default)
                or ecliptic frame in units of AU
        
        Note: Use eclip=True to get ecliptic coordinates.
        
        """
        
        # find time from Earth equinox and interpolated position
        dt = (currentTime - self.equinox).to('yr').value
        t_halo = dt % self.period_halo
        r_halo = self.r_halo_interp(t_halo).T
        # find Earth positions in heliocentric ecliptic frame
        r_Earth = self.solarSystem_body_position(currentTime, 'Earth',
                eclip=True).to('AU').value
        # adding Earth-Sun distances (projected in ecliptic plane)
        r_Earth_norm = np.linalg.norm(r_Earth[:,0:2], axis=1)
        r_halo[:,0] = r_halo[:,0] + r_Earth_norm
        # Earth ecliptic longitudes
        lon = np.sign(r_Earth[:,1])*np.arccos(r_Earth[:,0]/r_Earth_norm)
        # observatory positions vector in heliocentric ecliptic frame
        r_obs = np.array([np.dot(self.rot(-lon[x], 3), 
                r_halo[x,:]) for x in range(currentTime.size)])*u.AU
        
        assert np.all(np.isfinite(r_obs)), \
                "Observatory positions vector r_obs has infinite value."
        
        if not eclip:
            # observatory positions vector in heliocentric equatorial frame
            r_obs = self.eclip2equat(r_obs, currentTime)
        
        return r_obs
    
    def haloPosition(self,currentTime):
        """ This method returns the position vector of the WFIRST observatory 
        in the rotating frame of the Earth-Sun system centered at L2.
        """
        # Find the time between Earth equinox and current time(s)
        
        dt = (currentTime - self.equinox).to('yr').value
        t_halo = dt % self.period_halo
        
        # Interpolate to find correct observatory position(s)
        r_halo = self.r_halo_interp_L2(t_halo).T*u.AU
        
        return r_halo

    def haloVelocity(self,currentTime):
        """ Finds observatory velocity within its halo orbit about L2
        """
        # Find the time between Earth equinox and current time(s)
        
        dt = (currentTime - self.equinox).to('yr').value
        t_halo = dt % self.period_halo
        
        # Interpolate to find correct observatory velocity(-ies)
        v_halo = self.v_halo_interp(t_halo).T
        v_halo = v_halo*u.au/u.year
        
        return v_halo
    
    def equations_of_motion(self,t,s):
        """ Equations of motion for the Circular Restricted Three Body 
        Problem (CRTBP). First order form of the equations for integration, 
        returns 3 velocities and 3 accelerations in (x,y,z) rotating frame
            
        All parameters are normalized so that time = 2*pi sidereal year
        Distances normalized to 1AU
            
        Coordinates are taken in a rotating frame centered at the center of mass
        of the two primary bodies
            
        """
        
        #occulter distance from each of the two other bodies
        r1 = np.sqrt( (self.mu - s[0])**2 + s[1]**2 + s[2]**2 )
        r2 = np.sqrt( (1 - self.mu - s[0])**2 + s[1]**2 + s[2]**2 )
            
        #equations of motion
        ds1 = s[0] + 2*s[4] + self.m1*(-self.mu-s[0])/r1**3 + self.m2*(1-self.mu-s[0])/r2**3
        ds2 = s[1] - 2*s[3] - self.m1*s[1]/r1**3 - self.m2*s[1]/r2**3
        ds3 = -self.m1*s[2]/r1**3 - self.m2*s[2]/r2**3
        
        ds = np.vstack((s[3],s[4],s[5],ds1,ds2,ds3))
        
        return ds
    
    def star_angularSep(self,TL,N1,N2,tA,tB):
        
        t = np.linspace(tA.value,tB.value,2)    #discretizing time
        t = Time(t,format='mjd')                #converting time to modified julian date
        
        #position of WFIRST at the given times in rotating frame
        r_halo = self.haloPosition(t).to('au')
        r_WFIRST = (r_halo + np.array([1,0,0])*self.L2_dist).value
        
        #position of stars wrt to WFIRST
        star1 = self.eclip2rot(TL,N1,tA).value
        star2 = self.eclip2rot(TL,N2,tB).value
        
        star1_wfirst = star1 - r_WFIRST[ 0]
        star2_wfirst = star2 - r_WFIRST[-1]
        
        #corresponding unit vectors pointing WFIRST -> Target Star
        u1 = star1_wfirst / np.linalg.norm(star1_wfirst)
        u2 = star2_wfirst / np.linalg.norm(star2_wfirst)
        
        angle = (np.arccos(np.dot(u1[0],u2[0].T))*u.rad).to('deg')
        
        return angle.value
    
    
    def eclip2rot(self,TL,sInd,currentTime):
        
        star_pos = TL.starprop(sInd,currentTime)[0].to('au')
        theta    = (np.mod(currentTime.value,self.equinox.value[0])*u.d).to('yr') / u.yr * (2*np.pi)
        
        star_rot = np.array([np.dot(self.rot(theta.value, 3),star_pos.to('AU').value)])*u.AU

        return star_rot[0]
    
    def integrate(self,s0,t):
        """ Setting up integration using scipy odeint
        Tolerances are lowered and output info from integration is defined
        as an attribute.        
        """
        
        def EoM(y,t):
            """ Equations of motion for the Circular Restricted Three Body 
            Problem (CRTBP). First order form of the equations for integration, 
            returns 3 velocities and 3 accelerations in (x,y,z) rotating frame
            
            All parameters are normalized so that time = 2*pi sidereal year
            Distances normalized to 1AU
            
            Coordinates are taken in a rotating frame centered at the center of mass
            of the two primary bodies
            
            """
            #setting up state vector
            s1,s2,s3,s4,s5,s6 = y
        
            #occulter distance from each of the two other bodies
            r1 = np.sqrt( (self.mu - s1)**2 + s2**2 + s3**2 )
            r2 = np.sqrt( (1 - self.mu - s1)**2 + s2**2 + s3**2 )
            
            #equations of motion
            ds1 = s1 + 2*s5 + self.m1*(-self.mu-s1)/r1**3 + self.m2*(1-self.mu-s1)/r2**3
            ds2 = s2 - 2*s4 - self.m1*s2/r1**3 - self.m2*s2/r2**3
            ds3 = -self.m1*s3/r1**3 - self.m2*s3/r2**3
        
            ds = [s4,s5,s6,ds1,ds2,ds3]
        
            return ds
        
        sol,info = itg.odeint(EoM, s0, t, full_output = 1,rtol=2.5e-14,atol=1e-22)
        self.info = info
        
        return sol
